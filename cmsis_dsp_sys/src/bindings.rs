/* automatically generated by rust-bindgen 0.59.2 */

#[doc = " @brief 8-bit fractional data type in 1.7 format."]
pub type q7_t = i8;
#[doc = " @brief 16-bit fractional data type in 1.15 format."]
pub type q15_t = i16;
#[doc = " @brief 32-bit fractional data type in 1.31 format."]
pub type q31_t = i32;
#[doc = " @brief 64-bit fractional data type in 1.63 format."]
pub type q63_t = i64;
pub type float32_t = f32;
#[doc = " @brief 64-bit floating-point type definition."]
pub type float64_t = f64;
pub mod arm_status {
    #[doc = " @brief Error status returned by some functions in the library."]
    pub type Type = crate::ctypes::c_int;
    #[doc = "< No error"]
    pub const ARM_MATH_SUCCESS: Type = 0;
    #[doc = "< One or more arguments are incorrect"]
    pub const ARM_MATH_ARGUMENT_ERROR: Type = -1;
    #[doc = "< Length of data buffer is incorrect"]
    pub const ARM_MATH_LENGTH_ERROR: Type = -2;
    #[doc = "< Size of matrices is not compatible with the operation"]
    pub const ARM_MATH_SIZE_MISMATCH: Type = -3;
    #[doc = "< Not-a-number (NaN) or infinity is generated"]
    pub const ARM_MATH_NANINF: Type = -4;
    #[doc = "< Input matrix is singular and cannot be inverted"]
    pub const ARM_MATH_SINGULAR: Type = -5;
    #[doc = "< Test Failed"]
    pub const ARM_MATH_TEST_FAILURE: Type = -6;
    #[doc = "< Decomposition Failed"]
    pub const ARM_MATH_DECOMPOSITION_FAILURE: Type = -7;
}
extern "C" {
    #[doc = " @brief Q7 vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q15(pSrcA: *const q15_t, pSrcB: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q31(pSrcA: *const q31_t, pSrcB: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Floating-point vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Floating-point vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Floating-point vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q15(pSrcA: *const q15_t, pSrcB: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q31(pSrcA: *const q31_t, pSrcB: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Floating-point vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q15(pSrcA: *const q15_t, pSrcB: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q31(pSrcA: *const q31_t, pSrcB: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Multiplies a floating-point vector by a scalar."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  scale      scale factor to be applied"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_scale_f32(
        pSrc: *const float32_t,
        scale: float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a floating-point vector by a scalar."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  scale      scale factor to be applied"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_scale_f64(
        pSrc: *const float64_t,
        scale: float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q7 vector by a scalar."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale value"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q7(
        pSrc: *const q7_t,
        scaleFract: q7_t,
        shift: i8,
        pDst: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q15 vector by a scalar."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale value"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q15(
        pSrc: *const q15_t,
        scaleFract: q15_t,
        shift: i8,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q31 vector by a scalar."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale value"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q31(
        pSrc: *const q31_t,
        scaleFract: q31_t,
        shift: i8,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q7(pSrc: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_f64(pSrc: *const float64_t, pDst: *mut float64_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Dot product of floating-point vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        blockSize: u32,
        result: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of floating-point vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        blockSize: u32,
        result: *mut float64_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q7 vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q7(
        pSrcA: *const q7_t,
        pSrcB: *const q7_t,
        blockSize: u32,
        result: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q15 vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        blockSize: u32,
        result: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q31 vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        blockSize: u32,
        result: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q7 vector a specified number of bits."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right."]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q7(pSrc: *const q7_t, shiftBits: i8, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q15 vector a specified number of bits."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right."]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q15(pSrc: *const q15_t, shiftBits: i8, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q31 vector a specified number of bits."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right."]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q31(pSrc: *const q31_t, shiftBits: i8, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_f64(
        pSrc: *const float64_t,
        offset: float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_f32(
        pSrc: *const float32_t,
        offset: float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q7(pSrc: *const q7_t, offset: q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q15(pSrc: *const q15_t, offset: q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q31(pSrc: *const q31_t, offset: q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_f64(pSrc: *const float64_t, pDst: *mut float64_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q7(pSrc: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise AND of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_and_u16(pSrcA: *const u16, pSrcB: *const u16, pDst: *mut u16, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise AND of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_and_u32(pSrcA: *const u32, pSrcB: *const u32, pDst: *mut u32, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise AND of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_and_u8(pSrcA: *const u8, pSrcB: *const u8, pDst: *mut u8, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise OR of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_or_u16(pSrcA: *const u16, pSrcB: *const u16, pDst: *mut u16, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise OR of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_or_u32(pSrcA: *const u32, pSrcB: *const u32, pDst: *mut u32, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise OR of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_or_u8(pSrcA: *const u8, pSrcB: *const u8, pDst: *mut u8, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise NOT of a fixed-point vector."]
    #[doc = " @param[in]     pSrc       points to input vector"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_not_u16(pSrc: *const u16, pDst: *mut u16, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise NOT of a fixed-point vector."]
    #[doc = " @param[in]     pSrc       points to input vector"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_not_u32(pSrc: *const u32, pDst: *mut u32, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise NOT of a fixed-point vector."]
    #[doc = " @param[in]     pSrc       points to input vector"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_not_u8(pSrc: *const u8, pDst: *mut u8, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise XOR of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_xor_u16(pSrcA: *const u16, pSrcB: *const u16, pDst: *mut u16, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise XOR of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_xor_u32(pSrcA: *const u32, pSrcB: *const u32, pDst: *mut u32, blockSize: u32);
}
extern "C" {
    #[doc = " @brief         Compute the logical bitwise XOR of two fixed-point vectors."]
    #[doc = " @param[in]     pSrcA      points to input vector A"]
    #[doc = " @param[in]     pSrcB      points to input vector B"]
    #[doc = " @param[out]    pDst       points to output vector"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_xor_u8(pSrcA: *const u8, pSrcB: *const u8, pDst: *mut u8, blockSize: u32);
}
extern "C" {
    #[doc = "@brief         Elementwise floating-point clipping"]
    #[doc = "@param[in]     pSrc          points to input values"]
    #[doc = "@param[out]    pDst          points to output clipped values"]
    #[doc = "@param[in]     low           lower bound"]
    #[doc = "@param[in]     high          higher bound"]
    #[doc = "@param[in]     numSamples    number of samples to clip"]
    #[doc = "@return        none"]
    pub fn arm_clip_f32(
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        low: float32_t,
        high: float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = "@brief         Elementwise fixed-point clipping"]
    #[doc = "@param[in]     pSrc          points to input values"]
    #[doc = "@param[out]    pDst          points to output clipped values"]
    #[doc = "@param[in]     low           lower bound"]
    #[doc = "@param[in]     high          higher bound"]
    #[doc = "@param[in]     numSamples    number of samples to clip"]
    #[doc = "@return        none"]
    pub fn arm_clip_q31(
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        low: q31_t,
        high: q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = "@brief         Elementwise fixed-point clipping"]
    #[doc = "@param[in]     pSrc          points to input values"]
    #[doc = "@param[out]    pDst          points to output clipped values"]
    #[doc = "@param[in]     low           lower bound"]
    #[doc = "@param[in]     high          higher bound"]
    #[doc = "@param[in]     numSamples    number of samples to clip"]
    #[doc = "@return        none"]
    pub fn arm_clip_q15(
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        low: q15_t,
        high: q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = "@brief         Elementwise fixed-point clipping"]
    #[doc = "@param[in]     pSrc          points to input values"]
    #[doc = "@param[out]    pDst          points to output clipped values"]
    #[doc = "@param[in]     low           lower bound"]
    #[doc = "@param[in]     high          higher bound"]
    #[doc = "@param[in]     numSamples    number of samples to clip"]
    #[doc = "@return        none"]
    pub fn arm_clip_q7(pSrc: *const q7_t, pDst: *mut q7_t, low: q7_t, high: q7_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for floating-point data."]
    #[doc = " @param[in] x  input value in radians."]
    #[doc = " @return  sin(x)."]
    pub fn arm_sin_f32(x: float32_t) -> float32_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for Q31 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  sin(x)."]
    pub fn arm_sin_q31(x: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for Q15 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  sin(x)."]
    pub fn arm_sin_q15(x: q15_t) -> q15_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric cosine function for floating-point data."]
    #[doc = " @param[in] x  input value in radians."]
    #[doc = " @return  cos(x)."]
    pub fn arm_cos_f32(x: float32_t) -> float32_t;
}
extern "C" {
    #[doc = " @brief Fast approximation to the trigonometric cosine function for Q31 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  cos(x)."]
    pub fn arm_cos_q31(x: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric cosine function for Q15 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  cos(x)."]
    pub fn arm_cos_q15(x: q15_t) -> q15_t;
}
extern "C" {
    #[doc = "@brief         Floating-point vector of log values."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[out]    pDst       points to the output vector"]
    #[doc = "@param[in]     blockSize  number of samples in each vector"]
    #[doc = "@return        none"]
    pub fn arm_vlog_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = "@brief         Floating-point vector of log values."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[out]    pDst       points to the output vector"]
    #[doc = "@param[in]     blockSize  number of samples in each vector"]
    #[doc = "@return        none"]
    pub fn arm_vlog_f64(pSrc: *const float64_t, pDst: *mut float64_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  q31 vector of log values."]
    #[doc = " @param[in]     pSrc       points to the input vector in q31"]
    #[doc = " @param[out]    pDst       points to the output vector in q5.26"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_vlog_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  q15 vector of log values."]
    #[doc = " @param[in]     pSrc       points to the input vector in q15"]
    #[doc = " @param[out]    pDst       points to the output vector in q4.11"]
    #[doc = " @param[in]     blockSize  number of samples in each vector"]
    #[doc = " @return        none"]
    pub fn arm_vlog_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = "@brief         Floating-point vector of exp values."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[out]    pDst       points to the output vector"]
    #[doc = "@param[in]     blockSize  number of samples in each vector"]
    #[doc = "@return        none"]
    pub fn arm_vexp_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = "@brief         Floating-point vector of exp values."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[out]    pDst       points to the output vector"]
    #[doc = "@param[in]     blockSize  number of samples in each vector"]
    #[doc = "@return        none"]
    pub fn arm_vexp_f64(pSrc: *const float64_t, pDst: *mut float64_t, blockSize: u32);
}
extern "C" {
    #[doc = "@brief         Q31 square root function."]
    #[doc = "@param[in]     in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF"]
    #[doc = "@param[out]    pOut  points to square root of input value"]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS        : input value is positive"]
    #[doc = "- \\ref ARM_MATH_ARGUMENT_ERROR : input value is negative; *pOut is set to 0"]
    pub fn arm_sqrt_q31(in_: q31_t, pOut: *mut q31_t) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         Q15 square root function."]
    #[doc = "@param[in]     in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF"]
    #[doc = "@param[out]    pOut  points to square root of input value"]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS        : input value is positive"]
    #[doc = "- \\ref ARM_MATH_ARGUMENT_ERROR : input value is negative; *pOut is set to 0"]
    pub fn arm_sqrt_q15(in_: q15_t, pOut: *mut q15_t) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         Fixed point division"]
    #[doc = "@param[in]     numerator    Numerator"]
    #[doc = "@param[in]     denominator  Denominator"]
    #[doc = "@param[out]    quotient     Quotient value normalized between -1.0 and 1.0"]
    #[doc = "@param[out]    shift        Shift left value to get the unnormalized quotient"]
    #[doc = "@return        error status"]
    #[doc = ""]
    #[doc = "When dividing by 0, an error ARM_MATH_NANINF is returned. And the quotient is forced"]
    #[doc = "to the saturated negative or positive value."]
    pub fn arm_divide_q15(
        numerator: q15_t,
        denominator: q15_t,
        quotient: *mut q15_t,
        shift: *mut i16,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         Fixed point division"]
    #[doc = "@param[in]     numerator    Numerator"]
    #[doc = "@param[in]     denominator  Denominator"]
    #[doc = "@param[out]    quotient     Quotient value normalized between -1.0 and 1.0"]
    #[doc = "@param[out]    shift        Shift left value to get the unnormalized quotient"]
    #[doc = "@return        error status"]
    #[doc = ""]
    #[doc = "When dividing by 0, an error ARM_MATH_NANINF is returned. And the quotient is forced"]
    #[doc = "to the saturated negative or positive value."]
    pub fn arm_divide_q31(
        numerator: q31_t,
        denominator: q31_t,
        quotient: *mut q31_t,
        shift: *mut i16,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief  Arc tangent in radian of y/x using sign of x and y to determine right quadrant."]
    #[doc = "@param[in]   y  y coordinate"]
    #[doc = "@param[in]   x  x coordinate"]
    #[doc = "@param[out]  result  Result"]
    #[doc = "@return  error status."]
    pub fn arm_atan2_f32(y: float32_t, x: float32_t, result: *mut float32_t) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief  Arc tangent in radian of y/x using sign of x and y to determine right quadrant."]
    #[doc = "@param[in]   y  y coordinate"]
    #[doc = "@param[in]   x  x coordinate"]
    #[doc = "@param[out]  result  Result in Q2.29"]
    #[doc = "@return  error status."]
    pub fn arm_atan2_q31(y: q31_t, x: q31_t, result: *mut q31_t) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief  Arc tangent in radian of y/x using sign of x and y to determine right quadrant."]
    #[doc = "@param[in]   y  y coordinate"]
    #[doc = "@param[in]   x  x coordinate"]
    #[doc = "@param[out]  result  Result in Q2.13"]
    #[doc = "@return  error status."]
    pub fn arm_atan2_q15(y: q15_t, x: q15_t, result: *mut q15_t) -> arm_status::Type;
}
extern "C" {
    pub static armBitRevTable: [u16; 1024usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_16: [u16; 12usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_32: [u16; 24usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_64: [u16; 56usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_128: [u16; 112usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_256: [u16; 240usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_512: [u16; 480usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_1024: [u16; 992usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_2048: [u16; 1984usize];
}
extern "C" {
    pub static armBitRevIndexTableF64_4096: [u16; 4032usize];
}
extern "C" {
    pub static armBitRevIndexTable16: [u16; 20usize];
}
extern "C" {
    pub static armBitRevIndexTable32: [u16; 48usize];
}
extern "C" {
    pub static armBitRevIndexTable64: [u16; 56usize];
}
extern "C" {
    pub static armBitRevIndexTable128: [u16; 208usize];
}
extern "C" {
    pub static armBitRevIndexTable256: [u16; 440usize];
}
extern "C" {
    pub static armBitRevIndexTable512: [u16; 448usize];
}
extern "C" {
    pub static armBitRevIndexTable1024: [u16; 1800usize];
}
extern "C" {
    pub static armBitRevIndexTable2048: [u16; 3808usize];
}
extern "C" {
    pub static armBitRevIndexTable4096: [u16; 4032usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_16: [u16; 12usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_32: [u16; 24usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_64: [u16; 56usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_128: [u16; 112usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_256: [u16; 240usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_512: [u16; 480usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_1024: [u16; 992usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_2048: [u16; 1984usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_4096: [u16; 4032usize];
}
extern "C" {
    pub static armRecipTableQ15: [q15_t; 64usize];
}
extern "C" {
    pub static armRecipTableQ31: [q31_t; 64usize];
}
extern "C" {
    #[doc = " @brief  Floating-point complex conjugate."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_f32(pSrc: *const float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex conjugate."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_q31(pSrc: *const q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex conjugate."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_f32(pSrc: *const float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_f64(pSrc: *const float64_t, pDst: *mut float64_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_q31(pSrc: *const q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_f32(pSrc: *const float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_f64(pSrc: *const float64_t, pDst: *mut float64_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_q31(pSrc: *const q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_fast_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex dot product"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    #[doc = " @param[out] realResult  real part of the result returned here"]
    #[doc = " @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        numSamples: u32,
        realResult: *mut q31_t,
        imagResult: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex dot product"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    #[doc = " @param[out] realResult  real part of the result returned here"]
    #[doc = " @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        numSamples: u32,
        realResult: *mut q63_t,
        imagResult: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex dot product"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    #[doc = " @param[out] realResult  real part of the result returned here"]
    #[doc = " @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        numSamples: u32,
        realResult: *mut float32_t,
        imagResult: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Q15 complex-by-real multiplication"]
    #[doc = " @param[in]  pSrcCmplx   points to the complex input vector"]
    #[doc = " @param[in]  pSrcReal    points to the real input vector"]
    #[doc = " @param[out] pCmplxDst   points to the complex output vector"]
    #[doc = " @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_q15(
        pSrcCmplx: *const q15_t,
        pSrcReal: *const q15_t,
        pCmplxDst: *mut q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex-by-real multiplication"]
    #[doc = " @param[in]  pSrcCmplx   points to the complex input vector"]
    #[doc = " @param[in]  pSrcReal    points to the real input vector"]
    #[doc = " @param[out] pCmplxDst   points to the complex output vector"]
    #[doc = " @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_q31(
        pSrcCmplx: *const q31_t,
        pSrcReal: *const q31_t,
        pCmplxDst: *mut q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-real multiplication"]
    #[doc = " @param[in]  pSrcCmplx   points to the complex input vector"]
    #[doc = " @param[in]  pSrcReal    points to the real input vector"]
    #[doc = " @param[out] pCmplxDst   points to the complex output vector"]
    #[doc = " @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_f32(
        pSrcCmplx: *const float32_t,
        pSrcReal: *const float32_t,
        pCmplxDst: *mut float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q15 complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        pDst: *mut q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        pDst: *mut q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        pDst: *mut float64_t,
        numSamples: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix2_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Sin twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_q15(
        S: *mut arm_cfft_radix2_instance_q15,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix2_q15(S: *const arm_cfft_radix2_instance_q15, pSrc: *mut q15_t);
}
#[doc = " @brief Instance structure for the Q15 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix4_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_init_q15(
        S: *mut arm_cfft_radix4_instance_q15,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix4_q15(S: *const arm_cfft_radix4_instance_q15, pSrc: *mut q15_t);
}
#[doc = " @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix2_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_q31(
        S: *mut arm_cfft_radix2_instance_q31,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix2_q31(S: *const arm_cfft_radix2_instance_q31, pSrc: *mut q31_t);
}
#[doc = " @brief Instance structure for the Q31 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix4_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_q31(S: *const arm_cfft_radix4_instance_q31, pSrc: *mut q31_t);
}
extern "C" {
    pub fn arm_cfft_radix4_init_q31(
        S: *mut arm_cfft_radix4_instance_q31,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix2_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
    #[doc = "< value of 1/fftLen."]
    pub onebyfftLen: float32_t,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(bitRevFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).onebyfftLen as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(onebyfftLen)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_f32(
        S: *mut arm_cfft_radix2_instance_f32,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix2_f32(S: *const arm_cfft_radix2_instance_f32, pSrc: *mut float32_t);
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix4_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
    #[doc = "< value of 1/fftLen."]
    pub onebyfftLen: float32_t,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(bitRevFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).onebyfftLen as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(onebyfftLen)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_init_f32(
        S: *mut arm_cfft_radix4_instance_f32,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix4_f32(S: *const arm_cfft_radix4_instance_f32, pSrc: *mut float32_t);
}
#[doc = " @brief Instance structure for the fixed-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q15>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q15>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q15>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q15>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_init_q15(S: *mut arm_cfft_instance_q15, fftLen: u16) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_q15(
        S: *const arm_cfft_instance_q15,
        p1: *mut q15_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the fixed-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q31>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q31>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q31>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q31>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_init_q31(S: *mut arm_cfft_instance_q31, fftLen: u16) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_q31(
        S: *const arm_cfft_instance_q31,
        p1: *mut q31_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_f32>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_f32>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_f32>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_f32>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_init_f32(S: *mut arm_cfft_instance_f32, fftLen: u16) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_f32(
        S: *const arm_cfft_instance_f32,
        p1: *mut float32_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the Double Precision Floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_f64 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float64_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_f64>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_f64))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_f64>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_f64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_f64>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f64),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_f64>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f64),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_f64>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f64),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_f64>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f64),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_init_f64(S: *mut arm_cfft_instance_f64, fftLen: u16) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_f64(
        S: *const arm_cfft_instance_f64,
        p1: *mut float64_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the Q15 RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_instance_q15 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *const q15_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *const q15_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *const arm_cfft_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_q15>(),
        40usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).fftLenReal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).ifftFlagR as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).bitReverseFlagR as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).twidCoefRModifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).pTwiddleAReal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).pTwiddleBReal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_rfft_instance_q15>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_q15(
        S: *mut arm_rfft_instance_q15,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_q15(S: *const arm_rfft_instance_q15, pSrc: *mut q15_t, pDst: *mut q15_t);
}
#[doc = " @brief Instance structure for the Q31 RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_instance_q31 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *const q31_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *const q31_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *const arm_cfft_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_q31>(),
        40usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).fftLenReal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).ifftFlagR as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).bitReverseFlagR as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).twidCoefRModifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).pTwiddleAReal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).pTwiddleBReal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_rfft_instance_q31>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_q31(
        S: *mut arm_rfft_instance_q31,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_q31(S: *const arm_rfft_instance_q31, pSrc: *mut q31_t, pDst: *mut q31_t);
}
#[doc = " @brief Instance structure for the floating-point RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_instance_f32 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< length of the complex FFT."]
    pub fftLenBy2: u16,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *const float32_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *const float32_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).fftLenReal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).fftLenBy2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(fftLenBy2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).ifftFlagR as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).bitReverseFlagR as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).twidCoefRModifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).pTwiddleAReal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).pTwiddleBReal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_rfft_instance_f32>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_f32(
        S: *mut arm_rfft_instance_f32,
        S_CFFT: *mut arm_cfft_radix4_instance_f32,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_f32(
        S: *const arm_rfft_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the Double Precision Floating-point RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_fast_instance_f64 {
    #[doc = "< Internal CFFT structure."]
    pub Sint: arm_cfft_instance_f64,
    #[doc = "< length of the real sequence"]
    pub fftLenRFFT: u16,
    #[doc = "< Twiddle factors real stage"]
    pub pTwiddleRFFT: *const float64_t,
}
#[test]
fn bindgen_test_layout_arm_rfft_fast_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_fast_instance_f64>(),
        48usize,
        concat!("Size of: ", stringify!(arm_rfft_fast_instance_f64))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_fast_instance_f64>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_fast_instance_f64))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f64>())).Sint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f64),
            "::",
            stringify!(Sint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f64>())).fftLenRFFT as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f64),
            "::",
            stringify!(fftLenRFFT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f64>())).pTwiddleRFFT as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f64),
            "::",
            stringify!(pTwiddleRFFT)
        )
    );
}
extern "C" {
    pub fn arm_rfft_fast_init_f64(
        S: *mut arm_rfft_fast_instance_f64,
        fftLen: u16,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_fast_f64(
        S: *mut arm_rfft_fast_instance_f64,
        p: *mut float64_t,
        pOut: *mut float64_t,
        ifftFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_fast_instance_f32 {
    #[doc = "< Internal CFFT structure."]
    pub Sint: arm_cfft_instance_f32,
    #[doc = "< length of the real sequence"]
    pub fftLenRFFT: u16,
    #[doc = "< Twiddle factors real stage"]
    pub pTwiddleRFFT: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_rfft_fast_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_fast_instance_f32>(),
        48usize,
        concat!("Size of: ", stringify!(arm_rfft_fast_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_fast_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_fast_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f32>())).Sint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(Sint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f32>())).fftLenRFFT as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(fftLenRFFT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f32>())).pTwiddleRFFT as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(pTwiddleRFFT)
        )
    );
}
extern "C" {
    pub fn arm_rfft_fast_init_f32(
        S: *mut arm_rfft_fast_instance_f32,
        fftLen: u16,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_fast_f32(
        S: *const arm_rfft_fast_instance_f32,
        p: *mut float32_t,
        pOut: *mut float32_t,
        ifftFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point DCT4/IDCT4 function."]
#[repr(C)]
pub struct arm_dct4_instance_f32 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: float32_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *const float32_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_f32,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).Nby2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_f32>())).normalize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pCosFactor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pRfft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point DCT4/IDCT4."]
    #[doc = " @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure."]
    #[doc = " @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure."]
    #[doc = " @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure."]
    #[doc = " @param[in]     N          length of the DCT4."]
    #[doc = " @param[in]     Nby2       half of the length of the DCT4."]
    #[doc = " @param[in]     normalize  normalizing factor."]
    #[doc = " @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length."]
    pub fn arm_dct4_init_f32(
        S: *mut arm_dct4_instance_f32,
        S_RFFT: *mut arm_rfft_instance_f32,
        S_CFFT: *mut arm_cfft_radix4_instance_f32,
        N: u16,
        Nby2: u16,
        normalize: float32_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point DCT4/IDCT4."]
    #[doc = " @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure."]
    #[doc = " @param[in]     pState         points to state buffer."]
    #[doc = " @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_f32(
        S: *const arm_dct4_instance_f32,
        pState: *mut float32_t,
        pInlineBuffer: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the Q31 DCT4/IDCT4 function."]
#[repr(C)]
pub struct arm_dct4_instance_q31 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: q31_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *const q31_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_q31,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_q31>(),
        40usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).Nby2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q31>())).normalize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pCosFactor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pRfft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 DCT4/IDCT4."]
    #[doc = " @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure."]
    #[doc = " @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure"]
    #[doc = " @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure"]
    #[doc = " @param[in]     N          length of the DCT4."]
    #[doc = " @param[in]     Nby2       half of the length of the DCT4."]
    #[doc = " @param[in]     normalize  normalizing factor."]
    #[doc = " @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length."]
    pub fn arm_dct4_init_q31(
        S: *mut arm_dct4_instance_q31,
        S_RFFT: *mut arm_rfft_instance_q31,
        S_CFFT: *mut arm_cfft_radix4_instance_q31,
        N: u16,
        Nby2: u16,
        normalize: q31_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 DCT4/IDCT4."]
    #[doc = " @param[in]     S              points to an instance of the Q31 DCT4 structure."]
    #[doc = " @param[in]     pState         points to state buffer."]
    #[doc = " @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_q31(
        S: *const arm_dct4_instance_q31,
        pState: *mut q31_t,
        pInlineBuffer: *mut q31_t,
    );
}
#[doc = " @brief Instance structure for the Q15 DCT4/IDCT4 function."]
#[repr(C)]
pub struct arm_dct4_instance_q15 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: q15_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *const q15_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_q15,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_q15>(),
        40usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).Nby2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q15>())).normalize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pCosFactor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pRfft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 DCT4/IDCT4."]
    #[doc = " @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure."]
    #[doc = " @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure."]
    #[doc = " @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure."]
    #[doc = " @param[in]     N          length of the DCT4."]
    #[doc = " @param[in]     Nby2       half of the length of the DCT4."]
    #[doc = " @param[in]     normalize  normalizing factor."]
    #[doc = " @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length."]
    pub fn arm_dct4_init_q15(
        S: *mut arm_dct4_instance_q15,
        S_RFFT: *mut arm_rfft_instance_q15,
        S_CFFT: *mut arm_cfft_radix4_instance_q15,
        N: u16,
        Nby2: u16,
        normalize: q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 DCT4/IDCT4."]
    #[doc = " @param[in]     S              points to an instance of the Q15 DCT4 structure."]
    #[doc = " @param[in]     pState         points to state buffer."]
    #[doc = " @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_q15(
        S: *const arm_dct4_instance_q15,
        pState: *mut q15_t,
        pInlineBuffer: *mut q15_t,
    );
}
#[doc = " @brief Instance structure for the Floating-point MFCC function."]
#[repr(C)]
pub struct arm_mfcc_instance_f32 {
    #[doc = "< Internal DCT coefficients"]
    pub dctCoefs: *const float32_t,
    #[doc = "< Internal Mel filter coefficients"]
    pub filterCoefs: *const float32_t,
    #[doc = "< Windowing coefficients"]
    pub windowCoefs: *const float32_t,
    #[doc = "< Internal Mel filter positions in spectrum"]
    pub filterPos: *const u32,
    #[doc = "< Internal Mel filter  lengths"]
    pub filterLengths: *const u32,
    #[doc = "< FFT length"]
    pub fftLen: u32,
    #[doc = "< Number of Mel filters"]
    pub nbMelFilters: u32,
    #[doc = "< Number of DCT outputs"]
    pub nbDctOutputs: u32,
    pub rfft: arm_rfft_fast_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_mfcc_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_mfcc_instance_f32>(),
        104usize,
        concat!("Size of: ", stringify!(arm_mfcc_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_mfcc_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_mfcc_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).dctCoefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(dctCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).filterCoefs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(filterCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).windowCoefs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(windowCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).filterPos as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(filterPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).filterLengths as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(filterLengths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).fftLen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).nbMelFilters as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(nbMelFilters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).nbDctOutputs as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(nbDctOutputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_f32>())).rfft as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_f32),
            "::",
            stringify!(rfft)
        )
    );
}
extern "C" {
    pub fn arm_mfcc_init_f32(
        S: *mut arm_mfcc_instance_f32,
        fftLen: u32,
        nbMelFilters: u32,
        nbDctOutputs: u32,
        dctCoefs: *const float32_t,
        filterPos: *const u32,
        filterLengths: *const u32,
        filterCoefs: *const float32_t,
        windowCoefs: *const float32_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         MFCC F32"]
    #[doc = "@param[in]    S       points to the mfcc instance structure"]
    #[doc = "@param[in]     pSrc points to the input samples"]
    #[doc = "@param[out]     pDst  points to the output MFCC values"]
    #[doc = "@param[inout]     pTmp  points to a temporary buffer of complex"]
    #[doc = "@return        none"]
    pub fn arm_mfcc_f32(
        S: *const arm_mfcc_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        pTmp: *mut float32_t,
    );
}
#[repr(C)]
pub struct arm_mfcc_instance_q31 {
    #[doc = "< Internal DCT coefficients"]
    pub dctCoefs: *const q31_t,
    #[doc = "< Internal Mel filter coefficients"]
    pub filterCoefs: *const q31_t,
    #[doc = "< Windowing coefficients"]
    pub windowCoefs: *const q31_t,
    #[doc = "< Internal Mel filter positions in spectrum"]
    pub filterPos: *const u32,
    #[doc = "< Internal Mel filter  lengths"]
    pub filterLengths: *const u32,
    #[doc = "< FFT length"]
    pub fftLen: u32,
    #[doc = "< Number of Mel filters"]
    pub nbMelFilters: u32,
    #[doc = "< Number of DCT outputs"]
    pub nbDctOutputs: u32,
    pub rfft: arm_rfft_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_mfcc_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_mfcc_instance_q31>(),
        96usize,
        concat!("Size of: ", stringify!(arm_mfcc_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_mfcc_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_mfcc_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).dctCoefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(dctCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).filterCoefs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(filterCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).windowCoefs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(windowCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).filterPos as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(filterPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).filterLengths as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(filterLengths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).fftLen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).nbMelFilters as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(nbMelFilters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).nbDctOutputs as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(nbDctOutputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_q31>())).rfft as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q31),
            "::",
            stringify!(rfft)
        )
    );
}
extern "C" {
    pub fn arm_mfcc_init_q31(
        S: *mut arm_mfcc_instance_q31,
        fftLen: u32,
        nbMelFilters: u32,
        nbDctOutputs: u32,
        dctCoefs: *const q31_t,
        filterPos: *const u32,
        filterLengths: *const u32,
        filterCoefs: *const q31_t,
        windowCoefs: *const q31_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         MFCC Q31"]
    #[doc = "@param[in]    S       points to the mfcc instance structure"]
    #[doc = "@param[in]     pSrc points to the input samples"]
    #[doc = "@param[out]     pDst  points to the output MFCC values"]
    #[doc = "@param[inout]     pTmp  points to a temporary buffer of complex"]
    #[doc = "@return        none"]
    pub fn arm_mfcc_q31(
        S: *const arm_mfcc_instance_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        pTmp: *mut q31_t,
    ) -> arm_status::Type;
}
#[repr(C)]
pub struct arm_mfcc_instance_q15 {
    #[doc = "< Internal DCT coefficients"]
    pub dctCoefs: *const q15_t,
    #[doc = "< Internal Mel filter coefficients"]
    pub filterCoefs: *const q15_t,
    #[doc = "< Windowing coefficients"]
    pub windowCoefs: *const q15_t,
    #[doc = "< Internal Mel filter positions in spectrum"]
    pub filterPos: *const u32,
    #[doc = "< Internal Mel filter  lengths"]
    pub filterLengths: *const u32,
    #[doc = "< FFT length"]
    pub fftLen: u32,
    #[doc = "< Number of Mel filters"]
    pub nbMelFilters: u32,
    #[doc = "< Number of DCT outputs"]
    pub nbDctOutputs: u32,
    pub rfft: arm_rfft_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_mfcc_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_mfcc_instance_q15>(),
        96usize,
        concat!("Size of: ", stringify!(arm_mfcc_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_mfcc_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_mfcc_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).dctCoefs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(dctCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).filterCoefs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(filterCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).windowCoefs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(windowCoefs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).filterPos as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(filterPos)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).filterLengths as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(filterLengths)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).fftLen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).nbMelFilters as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(nbMelFilters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).nbDctOutputs as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(nbDctOutputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_mfcc_instance_q15>())).rfft as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_mfcc_instance_q15),
            "::",
            stringify!(rfft)
        )
    );
}
extern "C" {
    pub fn arm_mfcc_init_q15(
        S: *mut arm_mfcc_instance_q15,
        fftLen: u32,
        nbMelFilters: u32,
        nbDctOutputs: u32,
        dctCoefs: *const q15_t,
        filterPos: *const u32,
        filterLengths: *const u32,
        filterCoefs: *const q15_t,
        windowCoefs: *const q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         MFCC Q15"]
    #[doc = "@param[in]    S       points to the mfcc instance structure"]
    #[doc = "@param[in]     pSrc points to the input samples"]
    #[doc = "@param[out]     pDst  points to the output MFCC values in q8.7 format"]
    #[doc = "@param[inout]     pTmp  points to a temporary buffer of complex"]
    #[doc = "@return        error status"]
    pub fn arm_mfcc_q15(
        S: *const arm_mfcc_instance_q15,
        pSrc: *mut q15_t,
        pDst: *mut q15_t,
        pTmp: *mut q31_t,
    ) -> arm_status::Type;
}
extern "C" {
    pub static arm_cfft_sR_f64_len16: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len32: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len64: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len128: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len256: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len512: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len1024: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len2048: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f64_len4096: arm_cfft_instance_f64;
}
extern "C" {
    pub static arm_cfft_sR_f32_len16: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len32: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len64: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len128: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len256: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len512: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len1024: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len2048: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len4096: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_q31_len16: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len32: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len64: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len128: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len256: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len512: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len1024: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len2048: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len4096: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q15_len16: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len32: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len64: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len128: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len256: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len512: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len1024: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len2048: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len4096: arm_cfft_instance_q15;
}
#[doc = " @brief Instance structure for the floating-point Linear Interpolate function."]
#[repr(C)]
pub struct arm_linear_interp_instance_f32 {
    #[doc = "< nValues"]
    pub nValues: u32,
    #[doc = "< x1"]
    pub x1: float32_t,
    #[doc = "< xSpacing"]
    pub xSpacing: float32_t,
    #[doc = "< pointer to the table of Y values"]
    pub pYData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_linear_interp_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_linear_interp_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_linear_interp_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_linear_interp_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_linear_interp_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_linear_interp_instance_f32>())).nValues as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(nValues)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_linear_interp_instance_f32>())).x1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(x1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_linear_interp_instance_f32>())).xSpacing as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(xSpacing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_linear_interp_instance_f32>())).pYData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_linear_interp_instance_f32),
            "::",
            stringify!(pYData)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point bilinear interpolation function."]
#[repr(C)]
pub struct arm_bilinear_interp_instance_f32 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_bilinear_interp_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_f32>())).numRows as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_f32),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_f32>())).numCols as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_f32),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_f32>())).pData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_f32),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 bilinear interpolation function."]
#[repr(C)]
pub struct arm_bilinear_interp_instance_q31 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_q31>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_bilinear_interp_instance_q31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q31>())).numRows as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q31),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q31>())).numCols as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q31),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q31>())).pData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q31),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 bilinear interpolation function."]
#[repr(C)]
pub struct arm_bilinear_interp_instance_q15 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_q15>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_bilinear_interp_instance_q15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q15>())).numRows as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q15),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q15>())).numCols as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q15),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q15>())).pData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q15),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 bilinear interpolation function."]
#[repr(C)]
pub struct arm_bilinear_interp_instance_q7 {
    #[doc = "< number of rows in the data table."]
    pub numRows: u16,
    #[doc = "< number of columns in the data table."]
    pub numCols: u16,
    #[doc = "< points to the data table."]
    pub pData: *mut q7_t,
}
#[test]
fn bindgen_test_layout_arm_bilinear_interp_instance_q7() {
    assert_eq!(
        ::core::mem::size_of::<arm_bilinear_interp_instance_q7>(),
        16usize,
        concat!("Size of: ", stringify!(arm_bilinear_interp_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_bilinear_interp_instance_q7>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_bilinear_interp_instance_q7))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q7>())).numRows as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q7),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q7>())).numCols as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q7),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_bilinear_interp_instance_q7>())).pData as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_bilinear_interp_instance_q7),
            "::",
            stringify!(pData)
        )
    );
}
pub mod arm_spline_type {
    #[doc = " @brief Struct for specifying cubic spline type"]
    pub type Type = crate::ctypes::c_uint;
    #[doc = "< Natural spline"]
    pub const ARM_SPLINE_NATURAL: Type = 0;
    #[doc = "< Parabolic runout spline"]
    pub const ARM_SPLINE_PARABOLIC_RUNOUT: Type = 1;
}
#[doc = " @brief Instance structure for the floating-point cubic spline interpolation."]
#[repr(C)]
pub struct arm_spline_instance_f32 {
    #[doc = "< Type (boundary conditions)"]
    pub type_: arm_spline_type::Type,
    #[doc = "< x values"]
    pub x: *const float32_t,
    #[doc = "< y values"]
    pub y: *const float32_t,
    #[doc = "< Number of known data points"]
    pub n_x: u32,
    #[doc = "< Coefficients buffer (b,c, and d)"]
    pub coeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_spline_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_spline_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_spline_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_spline_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_spline_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_spline_instance_f32>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_spline_instance_f32),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_spline_instance_f32>())).x as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_spline_instance_f32),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_spline_instance_f32>())).y as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_spline_instance_f32),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_spline_instance_f32>())).n_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_spline_instance_f32),
            "::",
            stringify!(n_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_spline_instance_f32>())).coeffs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_spline_instance_f32),
            "::",
            stringify!(coeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point cubic spline interpolation."]
    #[doc = " @param[in]  S          points to an instance of the floating-point spline structure."]
    #[doc = " @param[in]  xq         points to the x values ot the interpolated data points."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples of output data."]
    pub fn arm_spline_f32(
        S: *mut arm_spline_instance_f32,
        xq: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point cubic spline interpolation."]
    #[doc = " @param[in,out] S        points to an instance of the floating-point spline structure."]
    #[doc = " @param[in]     type     type of cubic spline interpolation (boundary conditions)"]
    #[doc = " @param[in]     x        points to the x values of the known data points."]
    #[doc = " @param[in]     y        points to the y values of the known data points."]
    #[doc = " @param[in]     n        number of known data points."]
    #[doc = " @param[in]     coeffs   coefficients array for b, c, and d"]
    #[doc = " @param[in]     tempBuffer   buffer array for internal computations"]
    pub fn arm_spline_init_f32(
        S: *mut arm_spline_instance_f32,
        type_: arm_spline_type::Type,
        x: *const float32_t,
        y: *const float32_t,
        n: u32,
        coeffs: *mut float32_t,
        tempBuffer: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Process function for the floating-point Linear Interpolation Function."]
    #[doc = " @param[in,out] S  is an instance of the floating-point Linear Interpolation structure"]
    #[doc = " @param[in]     x  input sample to process"]
    #[doc = " @return y processed output sample."]
    #[doc = ""]
    pub fn arm_linear_interp_f32(S: *mut arm_linear_interp_instance_f32, x: float32_t)
        -> float32_t;
}
extern "C" {
    #[doc = " @brief  Process function for the Q31 Linear Interpolation Function."]
    #[doc = " @param[in] pYData   pointer to Q31 Linear Interpolation table"]
    #[doc = " @param[in] x        input sample to process"]
    #[doc = " @param[in] nValues  number of table values"]
    #[doc = " @return y processed output sample."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part."]
    #[doc = " This function can support maximum of table size 2^12."]
    #[doc = ""]
    pub fn arm_linear_interp_q31(pYData: *const q31_t, x: q31_t, nValues: u32) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Process function for the Q15 Linear Interpolation Function."]
    #[doc = " @param[in] pYData   pointer to Q15 Linear Interpolation table"]
    #[doc = " @param[in] x        input sample to process"]
    #[doc = " @param[in] nValues  number of table values"]
    #[doc = " @return y processed output sample."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part."]
    #[doc = " This function can support maximum of table size 2^12."]
    #[doc = ""]
    pub fn arm_linear_interp_q15(pYData: *const q15_t, x: q31_t, nValues: u32) -> q15_t;
}
extern "C" {
    #[doc = " @brief  Process function for the Q7 Linear Interpolation Function."]
    #[doc = " @param[in] pYData   pointer to Q7 Linear Interpolation table"]
    #[doc = " @param[in] x        input sample to process"]
    #[doc = " @param[in] nValues  number of table values"]
    #[doc = " @return y processed output sample."]
    #[doc = ""]
    #[doc = " \\par"]
    #[doc = " Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part."]
    #[doc = " This function can support maximum of table size 2^12."]
    pub fn arm_linear_interp_q7(pYData: *const q7_t, x: q31_t, nValues: u32) -> q7_t;
}
extern "C" {
    #[doc = " @brief  Floating-point bilinear interpolation."]
    #[doc = " @param[in,out] S  points to an instance of the interpolation structure."]
    #[doc = " @param[in]     X  interpolation coordinate."]
    #[doc = " @param[in]     Y  interpolation coordinate."]
    #[doc = " @return out interpolated value."]
    pub fn arm_bilinear_interp_f32(
        S: *const arm_bilinear_interp_instance_f32,
        X: float32_t,
        Y: float32_t,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief  Q31 bilinear interpolation."]
    #[doc = " @param[in,out] S  points to an instance of the interpolation structure."]
    #[doc = " @param[in]     X  interpolation coordinate in 12.20 format."]
    #[doc = " @param[in]     Y  interpolation coordinate in 12.20 format."]
    #[doc = " @return out interpolated value."]
    pub fn arm_bilinear_interp_q31(
        S: *mut arm_bilinear_interp_instance_q31,
        X: q31_t,
        Y: q31_t,
    ) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Q15 bilinear interpolation."]
    #[doc = " @param[in,out] S  points to an instance of the interpolation structure."]
    #[doc = " @param[in]     X  interpolation coordinate in 12.20 format."]
    #[doc = " @param[in]     Y  interpolation coordinate in 12.20 format."]
    #[doc = " @return out interpolated value."]
    pub fn arm_bilinear_interp_q15(
        S: *mut arm_bilinear_interp_instance_q15,
        X: q31_t,
        Y: q31_t,
    ) -> q15_t;
}
extern "C" {
    #[doc = " @brief  Q7 bilinear interpolation."]
    #[doc = " @param[in,out] S  points to an instance of the interpolation structure."]
    #[doc = " @param[in]     X  interpolation coordinate in 12.20 format."]
    #[doc = " @param[in]     Y  interpolation coordinate in 12.20 format."]
    #[doc = " @return out interpolated value."]
    pub fn arm_bilinear_interp_q7(
        S: *mut arm_bilinear_interp_instance_q7,
        X: q31_t,
        Y: q31_t,
    ) -> q7_t;
}
extern "C" {
    #[doc = " @brief Computation of the LogSumExp"]
    #[doc = ""]
    #[doc = " In probabilistic computations, the dynamic of the probability values can be very"]
    #[doc = " wide because they come from gaussian functions."]
    #[doc = " To avoid underflow and overflow issues, the values are represented by their log."]
    #[doc = " In this representation, multiplying the original exp values is easy : their logs are added."]
    #[doc = " But adding the original exp values is requiring some special handling and it is the"]
    #[doc = " goal of the LogSumExp function."]
    #[doc = ""]
    #[doc = " If the values are x1...xn, the function is computing:"]
    #[doc = ""]
    #[doc = " ln(exp(x1) + ... + exp(xn)) and the computation is done in such a way that"]
    #[doc = " rounding issues are minimised."]
    #[doc = ""]
    #[doc = " The max xm of the values is extracted and the function is computing:"]
    #[doc = " xm + ln(exp(x1 - xm) + ... + exp(xn - xm))"]
    #[doc = ""]
    #[doc = " @param[in]  *in         Pointer to an array of input values."]
    #[doc = " @param[in]  blockSize   Number of samples in the input array."]
    #[doc = " @return LogSumExp"]
    #[doc = ""]
    pub fn arm_logsumexp_f32(in_: *const float32_t, blockSize: u32) -> float32_t;
}
extern "C" {
    #[doc = " @brief Dot product with log arithmetic"]
    #[doc = ""]
    #[doc = " Vectors are containing the log of the samples"]
    #[doc = ""]
    #[doc = " @param[in]       pSrcA points to the first input vector"]
    #[doc = " @param[in]       pSrcB points to the second input vector"]
    #[doc = " @param[in]       blockSize number of samples in each vector"]
    #[doc = " @param[in]       pTmpBuffer temporary buffer of length blockSize"]
    #[doc = " @return The log of the dot product ."]
    #[doc = ""]
    pub fn arm_logsumexp_dot_prod_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        blockSize: u32,
        pTmpBuffer: *mut float32_t,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief Entropy"]
    #[doc = ""]
    #[doc = " @param[in]  pSrcA        Array of input values."]
    #[doc = " @param[in]  blockSize    Number of samples in the input array."]
    #[doc = " @return     Entropy      -Sum(p ln p)"]
    #[doc = ""]
    pub fn arm_entropy_f32(pSrcA: *const float32_t, blockSize: u32) -> float32_t;
}
extern "C" {
    #[doc = " @brief Entropy"]
    #[doc = ""]
    #[doc = " @param[in]  pSrcA        Array of input values."]
    #[doc = " @param[in]  blockSize    Number of samples in the input array."]
    #[doc = " @return     Entropy      -Sum(p ln p)"]
    #[doc = ""]
    pub fn arm_entropy_f64(pSrcA: *const float64_t, blockSize: u32) -> float64_t;
}
extern "C" {
    #[doc = " @brief Kullback-Leibler"]
    #[doc = ""]
    #[doc = " @param[in]  pSrcA         Pointer to an array of input values for probability distribution A."]
    #[doc = " @param[in]  pSrcB         Pointer to an array of input values for probability distribution B."]
    #[doc = " @param[in]  blockSize     Number of samples in the input array."]
    #[doc = " @return Kullback-Leibler  Divergence D(A || B)"]
    #[doc = ""]
    pub fn arm_kullback_leibler_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief Kullback-Leibler"]
    #[doc = ""]
    #[doc = " @param[in]  pSrcA         Pointer to an array of input values for probability distribution A."]
    #[doc = " @param[in]  pSrcB         Pointer to an array of input values for probability distribution B."]
    #[doc = " @param[in]  blockSize     Number of samples in the input array."]
    #[doc = " @return Kullback-Leibler  Divergence D(A || B)"]
    #[doc = ""]
    pub fn arm_kullback_leibler_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        blockSize: u32,
    ) -> float64_t;
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q63_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q63_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_rms_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_rms_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_rms_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] result     is output pointer"]
    #[doc = " @param[in]  index      is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q7(pSrc: *const q7_t, blockSize: u32, result: *mut q7_t, index: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] result     is output pointer"]
    #[doc = " @param[in]  index      is the array index of the minimum value in the input buffer."]
    pub fn arm_absmin_q7(pSrc: *const q7_t, blockSize: u32, result: *mut q7_t, index: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] result     is output pointer"]
    pub fn arm_absmin_no_idx_q7(pSrc: *const q7_t, blockSize: u32, result: *mut q7_t);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[in]  pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[in]  pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_absmin_q15(
        pSrc: *const q15_t,
        blockSize: u32,
        pResult: *mut q15_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    pub fn arm_absmin_no_idx_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_absmin_q31(
        pSrc: *const q31_t,
        blockSize: u32,
        pResult: *mut q31_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    pub fn arm_absmin_no_idx_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Minimum value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_f32(
        pSrc: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_absmin_f32(
        pSrc: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    pub fn arm_absmin_no_idx_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Minimum value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_f64(
        pSrc: *const float64_t,
        blockSize: u32,
        pResult: *mut float64_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_absmin_f64(
        pSrc: *const float64_t,
        blockSize: u32,
        pResult: *mut float64_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    pub fn arm_absmin_no_idx_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_absmax_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    pub fn arm_absmax_no_idx_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_absmax_q15(
        pSrc: *const q15_t,
        blockSize: u32,
        pResult: *mut q15_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    pub fn arm_absmax_no_idx_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_absmax_q31(
        pSrc: *const q31_t,
        blockSize: u32,
        pResult: *mut q31_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    pub fn arm_absmax_no_idx_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief Maximum value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_f32(
        pSrc: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_absmax_f32(
        pSrc: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    pub fn arm_absmax_no_idx_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief Maximum value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_f64(
        pSrc: *const float64_t,
        blockSize: u32,
        pResult: *mut float64_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_absmax_f64(
        pSrc: *const float64_t,
        blockSize: u32,
        pResult: *mut float64_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of absolute values of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    pub fn arm_absmax_no_idx_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = "@brief         Maximum value of a floating-point vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    maximum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_max_no_idx_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = "@brief         Minimum value of a floating-point vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    minimum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_min_no_idx_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = "@brief         Maximum value of a floating-point vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    maximum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_max_no_idx_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = "@brief         Maximum value of a q31 vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    maximum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_max_no_idx_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = "@brief         Maximum value of a q15 vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    maximum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_max_no_idx_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = "@brief         Maximum value of a q7 vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    maximum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_max_no_idx_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = "@brief         Minimum value of a floating-point vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    minimum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_min_no_idx_f64(pSrc: *const float64_t, blockSize: u32, pResult: *mut float64_t);
}
extern "C" {
    #[doc = "@brief         Minimum value of a q31 vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    minimum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_min_no_idx_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = "@brief         Minimum value of a q15 vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    minimum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_min_no_idx_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = "@brief         Minimum value of a q7 vector."]
    #[doc = "@param[in]     pSrc       points to the input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    minimum value returned here"]
    #[doc = "@return        none"]
    pub fn arm_min_no_idx_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = "@brief         Mean square error between two Q7 vectors."]
    #[doc = "@param[in]     pSrcA       points to the first input vector"]
    #[doc = "@param[in]     pSrcB       points to the second input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    mean square error"]
    #[doc = "@return        none"]
    pub fn arm_mse_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = "@brief         Mean square error between two Q15 vectors."]
    #[doc = "@param[in]     pSrcA       points to the first input vector"]
    #[doc = "@param[in]     pSrcB       points to the second input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    mean square error"]
    #[doc = "@return        none"]
    pub fn arm_mse_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        blockSize: u32,
        pResult: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief         Mean square error between two Q31 vectors."]
    #[doc = "@param[in]     pSrcA       points to the first input vector"]
    #[doc = "@param[in]     pSrcB       points to the second input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    mean square error"]
    #[doc = "@return        none"]
    pub fn arm_mse_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        blockSize: u32,
        pResult: *mut q31_t,
    );
}
extern "C" {
    #[doc = "@brief         Mean square error between two single precision float vectors."]
    #[doc = "@param[in]     pSrcA       points to the first input vector"]
    #[doc = "@param[in]     pSrcB       points to the second input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    mean square error"]
    #[doc = "@return        none"]
    pub fn arm_mse_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
    );
}
extern "C" {
    #[doc = "@brief         Mean square error between two double precision float vectors."]
    #[doc = "@param[in]     pSrcA       points to the first input vector"]
    #[doc = "@param[in]     pSrcB       points to the second input vector"]
    #[doc = "@param[in]     blockSize  number of samples in input vector"]
    #[doc = "@param[out]    pResult    mean square error"]
    #[doc = "@return        none"]
    pub fn arm_mse_f64(
        pSrcA: *const float64_t,
        pSrcB: *const float64_t,
        blockSize: u32,
        pResult: *mut float64_t,
    );
}
#[doc = " @brief Instance structure for Naive Gaussian Bayesian estimator."]
#[repr(C)]
pub struct arm_gaussian_naive_bayes_instance_f32 {
    #[doc = "< Dimension of vector space"]
    pub vectorDimension: u32,
    #[doc = "< Number of different classes"]
    pub numberOfClasses: u32,
    #[doc = "< Mean values for the Gaussians"]
    pub theta: *const float32_t,
    #[doc = "< Variances for the Gaussians"]
    pub sigma: *const float32_t,
    #[doc = "< Class prior probabilities"]
    pub classPriors: *const float32_t,
    #[doc = "< Additive value to variances"]
    pub epsilon: float32_t,
}
#[test]
fn bindgen_test_layout_arm_gaussian_naive_bayes_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_gaussian_naive_bayes_instance_f32>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_gaussian_naive_bayes_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_gaussian_naive_bayes_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_gaussian_naive_bayes_instance_f32>())).vectorDimension
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32),
            "::",
            stringify!(vectorDimension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_gaussian_naive_bayes_instance_f32>())).numberOfClasses
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32),
            "::",
            stringify!(numberOfClasses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_gaussian_naive_bayes_instance_f32>())).theta as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32),
            "::",
            stringify!(theta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_gaussian_naive_bayes_instance_f32>())).sigma as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32),
            "::",
            stringify!(sigma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_gaussian_naive_bayes_instance_f32>())).classPriors
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32),
            "::",
            stringify!(classPriors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_gaussian_naive_bayes_instance_f32>())).epsilon as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_gaussian_naive_bayes_instance_f32),
            "::",
            stringify!(epsilon)
        )
    );
}
extern "C" {
    #[doc = " @brief Naive Gaussian Bayesian Estimator"]
    #[doc = ""]
    #[doc = " @param[in]  S                        points to a naive bayes instance structure"]
    #[doc = " @param[in]  in                       points to the elements of the input vector."]
    #[doc = " @param[out] *pOutputProbabilities    points to a buffer of length numberOfClasses containing estimated probabilities"]
    #[doc = " @param[out] *pBufferB                points to a temporary buffer of length numberOfClasses"]
    #[doc = " @return The predicted class"]
    #[doc = ""]
    pub fn arm_gaussian_naive_bayes_predict_f32(
        S: *const arm_gaussian_naive_bayes_instance_f32,
        in_: *const float32_t,
        pOutputProbabilities: *mut float32_t,
        pBufferB: *mut float32_t,
    ) -> u32;
}
#[doc = " @brief Instance structure for the floating-point matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_f32 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f32>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f32>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_f32>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_f64 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut float64_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_f64>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_f64))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_f64>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_f64))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f64>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f64>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_f64>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q7 matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_q7 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q7_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q7() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q7>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q7>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q7>())).numRows as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q7),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q7>())).numCols as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q7),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q7>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q7),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_q15 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q15>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q15>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q15>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_q31 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q31>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q31>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q31>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(pData)
        )
    );
}
extern "C" {
    #[doc = " @brief Floating-point matrix addition."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix addition."]
    #[doc = " @param[in]   pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]   pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out]  pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix addition."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point, complex, matrix multiplication."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15, complex,  matrix multiplication."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pScratch: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31, complex, matrix multiplication."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_f32(
        pSrc: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_f64(
        pSrc: *const arm_matrix_instance_f64,
        pDst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point complex matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_trans_f32(
        pSrc: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q15(
        pSrc: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 complex matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_trans_q15(
        pSrc: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q7 matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q7(
        pSrc: *const arm_matrix_instance_q7,
        pDst: *mut arm_matrix_instance_q7,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q31(
        pSrc: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 complex matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_trans_q31(
        pSrc: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix multiplication"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix multiplication"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_f64(
        pSrcA: *const arm_matrix_instance_f64,
        pSrcB: *const arm_matrix_instance_f64,
        pDst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix and vector multiplication"]
    #[doc = " @param[in]  pSrcMat  points to the input matrix structure"]
    #[doc = " @param[in]  pVec     points to vector"]
    #[doc = " @param[out] pDst     points to output vector"]
    pub fn arm_mat_vec_mult_f32(
        pSrcMat: *const arm_matrix_instance_f32,
        pVec: *const float32_t,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Q7 matrix multiplication"]
    #[doc = " @param[in]  pSrcA   points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB   points to the second input matrix structure"]
    #[doc = " @param[out] pDst    points to output matrix structure"]
    #[doc = " @param[in]  pState  points to the array for storing intermediate results"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q7(
        pSrcA: *const arm_matrix_instance_q7,
        pSrcB: *const arm_matrix_instance_q7,
        pDst: *mut arm_matrix_instance_q7,
        pState: *mut q7_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q7 matrix and vector multiplication"]
    #[doc = " @param[in]  pSrcMat  points to the input matrix structure"]
    #[doc = " @param[in]  pVec     points to vector"]
    #[doc = " @param[out] pDst     points to output vector"]
    pub fn arm_mat_vec_mult_q7(
        pSrcMat: *const arm_matrix_instance_q7,
        pVec: *const q7_t,
        pDst: *mut q7_t,
    );
}
extern "C" {
    #[doc = " @brief Q15 matrix multiplication"]
    #[doc = " @param[in]  pSrcA   points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB   points to the second input matrix structure"]
    #[doc = " @param[out] pDst    points to output matrix structure"]
    #[doc = " @param[in]  pState  points to the array for storing intermediate results"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pState: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix and vector multiplication"]
    #[doc = " @param[in]  pSrcMat  points to the input matrix structure"]
    #[doc = " @param[in]  pVec     points to vector"]
    #[doc = " @param[out] pDst     points to output vector"]
    pub fn arm_mat_vec_mult_q15(
        pSrcMat: *const arm_matrix_instance_q15,
        pVec: *const q15_t,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA   points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB   points to the second input matrix structure"]
    #[doc = " @param[out] pDst    points to output matrix structure"]
    #[doc = " @param[in]  pState  points to the array for storing intermediate results"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_fast_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pState: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @param[in]  pState  points to the array for storing intermediate results"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_opt_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
        pState: *mut q31_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix and vector multiplication"]
    #[doc = " @param[in]  pSrcMat  points to the input matrix structure"]
    #[doc = " @param[in]  pVec     points to vector"]
    #[doc = " @param[out] pDst     points to output vector"]
    pub fn arm_mat_vec_mult_q31(
        pSrcMat: *const arm_matrix_instance_q31,
        pVec: *const q31_t,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_fast_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_f64(
        pSrcA: *const arm_matrix_instance_f64,
        pSrcB: *const arm_matrix_instance_f64,
        pDst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix scaling."]
    #[doc = " @param[in]  pSrc   points to the input matrix"]
    #[doc = " @param[in]  scale  scale factor"]
    #[doc = " @param[out] pDst   points to the output matrix"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_f32(
        pSrc: *const arm_matrix_instance_f32,
        scale: float32_t,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix scaling."]
    #[doc = " @param[in]  pSrc        points to input matrix"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale factor"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to output matrix"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_q15(
        pSrc: *const arm_matrix_instance_q15,
        scaleFract: q15_t,
        shift: i32,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix scaling."]
    #[doc = " @param[in]  pSrc        points to input matrix"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale factor"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_q31(
        pSrc: *const arm_matrix_instance_q31,
        scaleFract: q31_t,
        shift: i32,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief  Q31 matrix initialization."]
    #[doc = " @param[in,out] S         points to an instance of the floating-point matrix structure."]
    #[doc = " @param[in]     nRows     number of rows in the matrix."]
    #[doc = " @param[in]     nColumns  number of columns in the matrix."]
    #[doc = " @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_q31(
        S: *mut arm_matrix_instance_q31,
        nRows: u16,
        nColumns: u16,
        pData: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief  Q15 matrix initialization."]
    #[doc = " @param[in,out] S         points to an instance of the floating-point matrix structure."]
    #[doc = " @param[in]     nRows     number of rows in the matrix."]
    #[doc = " @param[in]     nColumns  number of columns in the matrix."]
    #[doc = " @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_q15(
        S: *mut arm_matrix_instance_q15,
        nRows: u16,
        nColumns: u16,
        pData: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point matrix initialization."]
    #[doc = " @param[in,out] S         points to an instance of the floating-point matrix structure."]
    #[doc = " @param[in]     nRows     number of rows in the matrix."]
    #[doc = " @param[in]     nColumns  number of columns in the matrix."]
    #[doc = " @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_f32(
        S: *mut arm_matrix_instance_f32,
        nRows: u16,
        nColumns: u16,
        pData: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Floating-point matrix inverse."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] dst   points to the instance of the output floating-point matrix structure."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR."]
    pub fn arm_mat_inverse_f32(
        src: *const arm_matrix_instance_f32,
        dst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix inverse."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] dst   points to the instance of the output floating-point matrix structure."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR."]
    pub fn arm_mat_inverse_f64(
        src: *const arm_matrix_instance_f64,
        dst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point Cholesky decomposition of Symmetric Positive Definite Matrix."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] dst   points to the instance of the output floating-point matrix structure."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix does not have a decomposition, then the algorithm terminates and returns error status ARM_MATH_DECOMPOSITION_FAILURE."]
    #[doc = " If the matrix is ill conditioned or only semi-definite, then it is better using the LDL^t decomposition."]
    #[doc = " The decomposition is returning a lower triangular matrix."]
    pub fn arm_mat_cholesky_f64(
        src: *const arm_matrix_instance_f64,
        dst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point Cholesky decomposition of Symmetric Positive Definite Matrix."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] dst   points to the instance of the output floating-point matrix structure."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix does not have a decomposition, then the algorithm terminates and returns error status ARM_MATH_DECOMPOSITION_FAILURE."]
    #[doc = " If the matrix is ill conditioned or only semi-definite, then it is better using the LDL^t decomposition."]
    #[doc = " The decomposition is returning a lower triangular matrix."]
    pub fn arm_mat_cholesky_f32(
        src: *const arm_matrix_instance_f32,
        dst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Solve UT . X = A where UT is an upper triangular matrix"]
    #[doc = " @param[in]  ut  The upper triangular matrix"]
    #[doc = " @param[in]  a  The matrix a"]
    #[doc = " @param[out] dst The solution X of UT . X = A"]
    #[doc = " @return The function returns ARM_MATH_SINGULAR, if the system can't be solved."]
    pub fn arm_mat_solve_upper_triangular_f32(
        ut: *const arm_matrix_instance_f32,
        a: *const arm_matrix_instance_f32,
        dst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Solve LT . X = A where LT is a lower triangular matrix"]
    #[doc = " @param[in]  lt  The lower triangular matrix"]
    #[doc = " @param[in]  a  The matrix a"]
    #[doc = " @param[out] dst The solution X of LT . X = A"]
    #[doc = " @return The function returns ARM_MATH_SINGULAR, if the system can't be solved."]
    pub fn arm_mat_solve_lower_triangular_f32(
        lt: *const arm_matrix_instance_f32,
        a: *const arm_matrix_instance_f32,
        dst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Solve UT . X = A where UT is an upper triangular matrix"]
    #[doc = " @param[in]  ut  The upper triangular matrix"]
    #[doc = " @param[in]  a  The matrix a"]
    #[doc = " @param[out] dst The solution X of UT . X = A"]
    #[doc = " @return The function returns ARM_MATH_SINGULAR, if the system can't be solved."]
    pub fn arm_mat_solve_upper_triangular_f64(
        ut: *const arm_matrix_instance_f64,
        a: *const arm_matrix_instance_f64,
        dst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Solve LT . X = A where LT is a lower triangular matrix"]
    #[doc = " @param[in]  lt  The lower triangular matrix"]
    #[doc = " @param[in]  a  The matrix a"]
    #[doc = " @param[out] dst The solution X of LT . X = A"]
    #[doc = " @return The function returns ARM_MATH_SINGULAR, if the system can't be solved."]
    pub fn arm_mat_solve_lower_triangular_f64(
        lt: *const arm_matrix_instance_f64,
        a: *const arm_matrix_instance_f64,
        dst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point LDL decomposition of Symmetric Positive Semi-Definite Matrix."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] l   points to the instance of the output floating-point triangular matrix structure."]
    #[doc = " @param[out] d   points to the instance of the output floating-point diagonal matrix structure."]
    #[doc = " @param[out] p   points to the instance of the output floating-point permutation vector."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix does not have a decomposition, then the algorithm terminates and returns error status ARM_MATH_DECOMPOSITION_FAILURE."]
    #[doc = " The decomposition is returning a lower triangular matrix."]
    pub fn arm_mat_ldlt_f32(
        src: *const arm_matrix_instance_f32,
        l: *mut arm_matrix_instance_f32,
        d: *mut arm_matrix_instance_f32,
        pp: *mut u16,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point LDL decomposition of Symmetric Positive Semi-Definite Matrix."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] l   points to the instance of the output floating-point triangular matrix structure."]
    #[doc = " @param[out] d   points to the instance of the output floating-point diagonal matrix structure."]
    #[doc = " @param[out] p   points to the instance of the output floating-point permutation vector."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix does not have a decomposition, then the algorithm terminates and returns error status ARM_MATH_DECOMPOSITION_FAILURE."]
    #[doc = " The decomposition is returning a lower triangular matrix."]
    pub fn arm_mat_ldlt_f64(
        src: *const arm_matrix_instance_f64,
        l: *mut arm_matrix_instance_f64,
        d: *mut arm_matrix_instance_f64,
        pp: *mut u16,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         QR decomposition of a m x n floating point matrix with m >= n."]
    #[doc = "@param[in]     pSrc      points to input matrix structure. The source matrix is modified by the function."]
    #[doc = "@param[in]     threshold norm2 threshold."]
    #[doc = "@param[out]    pOutR     points to output R matrix structure of dimension m x n"]
    #[doc = "@param[out]    pOutQ     points to output Q matrix structure of dimension m x m"]
    #[doc = "@param[out]    pOutTau   points to Householder scaling factors of dimension n"]
    #[doc = "@param[inout]  pTmpA     points to a temporary vector of dimension m."]
    #[doc = "@param[inout]  pTmpB     points to a temporary vector of dimension n."]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS       : Operation successful"]
    #[doc = "- \\ref ARM_MATH_SIZE_MISMATCH : Matrix size check failed"]
    #[doc = "- \\ref ARM_MATH_SINGULAR      : Input matrix is found to be singular (non-invertible)"]
    pub fn arm_mat_qr_f32(
        pSrc: *const arm_matrix_instance_f32,
        threshold: float32_t,
        pOutR: *mut arm_matrix_instance_f32,
        pOutQ: *mut arm_matrix_instance_f32,
        pOutTau: *mut float32_t,
        pTmpA: *mut float32_t,
        pTmpB: *mut float32_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         QR decomposition of a m x n floating point matrix with m >= n."]
    #[doc = "@param[in]     pSrc      points to input matrix structure. The source matrix is modified by the function."]
    #[doc = "@param[in]     threshold norm2 threshold."]
    #[doc = "@param[out]    pOutR     points to output R matrix structure of dimension m x n"]
    #[doc = "@param[out]    pOutQ     points to output Q matrix structure of dimension m x m"]
    #[doc = "@param[out]    pOutTau   points to Householder scaling factors of dimension n"]
    #[doc = "@param[inout]  pTmpA     points to a temporary vector of dimension m."]
    #[doc = "@param[inout]  pTmpB     points to a temporary vector of dimension n."]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS       : Operation successful"]
    #[doc = "- \\ref ARM_MATH_SIZE_MISMATCH : Matrix size check failed"]
    #[doc = "- \\ref ARM_MATH_SINGULAR      : Input matrix is found to be singular (non-invertible)"]
    pub fn arm_mat_qr_f64(
        pSrc: *const arm_matrix_instance_f64,
        threshold: float64_t,
        pOutR: *mut arm_matrix_instance_f64,
        pOutQ: *mut arm_matrix_instance_f64,
        pOutTau: *mut float64_t,
        pTmpA: *mut float64_t,
        pTmpB: *mut float64_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         Householder transform of a floating point vector."]
    #[doc = "@param[in]     pSrc        points to the input vector."]
    #[doc = "@param[in]     threshold   norm2 threshold."]
    #[doc = "@param[in]     blockSize   dimension of the vector space."]
    #[doc = "@param[outQ]   pOut        points to the output vector."]
    #[doc = "@return        beta        return the scaling factor beta"]
    pub fn arm_householder_f32(
        pSrc: *const float32_t,
        threshold: float32_t,
        blockSize: u32,
        pOut: *mut float32_t,
    ) -> float32_t;
}
extern "C" {
    #[doc = "@brief         Householder transform of a double floating point vector."]
    #[doc = "@param[in]     pSrc        points to the input vector."]
    #[doc = "@param[in]     threshold   norm2 threshold."]
    #[doc = "@param[in]     blockSize   dimension of the vector space."]
    #[doc = "@param[outQ]   pOut        points to the output vector."]
    #[doc = "@return        beta        return the scaling factor beta"]
    pub fn arm_householder_f64(
        pSrc: *const float64_t,
        threshold: float64_t,
        blockSize: u32,
        pOut: *mut float64_t,
    ) -> float64_t;
}
extern "C" {
    #[doc = " @brief  Floating-point sin_cos function."]
    #[doc = " @param[in]  theta   input value in degrees"]
    #[doc = " @param[out] pSinVal  points to the processed sine output."]
    #[doc = " @param[out] pCosVal  points to the processed cos output."]
    pub fn arm_sin_cos_f32(theta: float32_t, pSinVal: *mut float32_t, pCosVal: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Q31 sin_cos function."]
    #[doc = " @param[in]  theta    scaled input value in degrees"]
    #[doc = " @param[out] pSinVal  points to the processed sine output."]
    #[doc = " @param[out] pCosVal  points to the processed cosine output."]
    pub fn arm_sin_cos_q31(theta: q31_t, pSinVal: *mut q31_t, pCosVal: *mut q31_t);
}
#[doc = " @ingroup PID"]
#[doc = " @brief Instance structure for the Q15 PID Control."]
#[repr(C)]
pub struct arm_pid_instance_q15 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: q15_t,
    #[doc = "< The derived gain A1 = -Kp - 2Kd"]
    pub A1: q15_t,
    #[doc = "< The derived gain A1 = Kd."]
    pub A2: q15_t,
    #[doc = "< The state array of length 3."]
    pub state: [q15_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: q15_t,
    #[doc = "< The integral gain."]
    pub Ki: q15_t,
    #[doc = "< The derivative gain."]
    pub Kd: q15_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_q15>(),
        18usize,
        concat!("Size of: ", stringify!(arm_pid_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_q15>(),
        2usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).A0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).A1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).A2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).state as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).Kp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).Ki as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).Kd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Kd)
        )
    );
}
#[doc = " @ingroup PID"]
#[doc = " @brief Instance structure for the Q31 PID Control."]
#[repr(C)]
pub struct arm_pid_instance_q31 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: q31_t,
    #[doc = "< The derived gain, A1 = -Kp - 2Kd."]
    pub A1: q31_t,
    #[doc = "< The derived gain, A2 = Kd ."]
    pub A2: q31_t,
    #[doc = "< The state array of length 3."]
    pub state: [q31_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: q31_t,
    #[doc = "< The integral gain."]
    pub Ki: q31_t,
    #[doc = "< The derivative gain."]
    pub Kd: q31_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_q31>(),
        36usize,
        concat!("Size of: ", stringify!(arm_pid_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).A0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).A1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).A2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).Kp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).Ki as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).Kd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Kd)
        )
    );
}
#[doc = " @ingroup PID"]
#[doc = " @brief Instance structure for the floating-point PID Control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_pid_instance_f32 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: float32_t,
    #[doc = "< The derived gain, A1 = -Kp - 2Kd."]
    pub A1: float32_t,
    #[doc = "< The derived gain, A2 = Kd ."]
    pub A2: float32_t,
    #[doc = "< The state array of length 3."]
    pub state: [float32_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: float32_t,
    #[doc = "< The integral gain."]
    pub Ki: float32_t,
    #[doc = "< The derivative gain."]
    pub Kd: float32_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_f32>(),
        36usize,
        concat!("Size of: ", stringify!(arm_pid_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).A0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).A1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).A2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).Kp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).Ki as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).Kd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Kd)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point PID Control."]
    #[doc = " @param[in,out] S               points to an instance of the PID structure."]
    #[doc = " @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_f32(S: *mut arm_pid_instance_f32, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the floating-point PID Control."]
    #[doc = " @param[in,out] S  is an instance of the floating-point PID Control structure"]
    pub fn arm_pid_reset_f32(S: *mut arm_pid_instance_f32);
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 PID Control."]
    #[doc = " @param[in,out] S               points to an instance of the Q15 PID structure."]
    #[doc = " @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_q31(S: *mut arm_pid_instance_q31, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the Q31 PID Control."]
    #[doc = " @param[in,out] S   points to an instance of the Q31 PID Control structure"]
    pub fn arm_pid_reset_q31(S: *mut arm_pid_instance_q31);
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 PID Control."]
    #[doc = " @param[in,out] S               points to an instance of the Q15 PID structure."]
    #[doc = " @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_q15(S: *mut arm_pid_instance_q15, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the Q15 PID Control."]
    #[doc = " @param[in,out] S  points to an instance of the q15 PID Control structure"]
    pub fn arm_pid_reset_q15(S: *mut arm_pid_instance_q15);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the floating-point input vector"]
    #[doc = " @param[out] pDst       points to the Q31 output vector"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q31(pSrc: *const float32_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the floating-point input vector"]
    #[doc = " @param[out] pDst       points to the Q15 output vector"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q15(pSrc: *const float32_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the floating-point input vector"]
    #[doc = " @param[out] pDst       points to the Q7 output vector"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q7(pSrc: *const float32_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_float(pSrc: *const q31_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_q15(pSrc: *const q31_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_q7(pSrc: *const q31_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_float(pSrc: *const q15_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_q31(pSrc: *const q15_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_q7(pSrc: *const q15_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q7_to_float(pSrc: *const q7_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to Q31 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_q7_to_q31(pSrc: *const q7_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to Q15 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_q7_to_q15(pSrc: *const q7_t, pDst: *mut q15_t, blockSize: u32);
}
pub mod arm_sort_alg {
    #[doc = " @brief Struct for specifying sorting algorithm"]
    pub type Type = crate::ctypes::c_uint;
    pub const ARM_SORT_BITONIC: Type = 0;
    pub const ARM_SORT_BUBBLE: Type = 1;
    pub const ARM_SORT_HEAP: Type = 2;
    pub const ARM_SORT_INSERTION: Type = 3;
    pub const ARM_SORT_QUICK: Type = 4;
    pub const ARM_SORT_SELECTION: Type = 5;
}
pub mod arm_sort_dir {
    #[doc = " @brief Struct for specifying sorting algorithm"]
    pub type Type = crate::ctypes::c_uint;
    pub const ARM_SORT_DESCENDING: Type = 0;
    pub const ARM_SORT_ASCENDING: Type = 1;
}
#[doc = " @brief Instance structure for the sorting algorithms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_sort_instance_f32 {
    #[doc = "< Sorting algorithm selected"]
    pub alg: arm_sort_alg::Type,
    #[doc = "< Sorting order (direction)"]
    pub dir: arm_sort_dir::Type,
}
#[test]
fn bindgen_test_layout_arm_sort_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_sort_instance_f32>(),
        8usize,
        concat!("Size of: ", stringify!(arm_sort_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_sort_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_sort_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_sort_instance_f32>())).alg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_sort_instance_f32),
            "::",
            stringify!(alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_sort_instance_f32>())).dir as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_sort_instance_f32),
            "::",
            stringify!(dir)
        )
    );
}
extern "C" {
    #[doc = " @param[in]  S          points to an instance of the sorting structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_sort_f32(
        S: *const arm_sort_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @param[in,out]  S            points to an instance of the sorting structure."]
    #[doc = " @param[in]      alg          Selected algorithm."]
    #[doc = " @param[in]      dir          Sorting order."]
    pub fn arm_sort_init_f32(
        S: *mut arm_sort_instance_f32,
        alg: arm_sort_alg::Type,
        dir: arm_sort_dir::Type,
    );
}
#[doc = " @brief Instance structure for the sorting algorithms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_merge_sort_instance_f32 {
    #[doc = "< Sorting order (direction)"]
    pub dir: arm_sort_dir::Type,
    #[doc = "< Working buffer"]
    pub buffer: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_merge_sort_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_merge_sort_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_merge_sort_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_merge_sort_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_merge_sort_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_merge_sort_instance_f32>())).dir as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_merge_sort_instance_f32),
            "::",
            stringify!(dir)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_merge_sort_instance_f32>())).buffer as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_merge_sort_instance_f32),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[doc = " @param[in]      S          points to an instance of the sorting structure."]
    #[doc = " @param[in,out]  pSrc       points to the block of input data."]
    #[doc = " @param[out]     pDst       points to the block of output data"]
    #[doc = " @param[in]      blockSize  number of samples to process."]
    pub fn arm_merge_sort_f32(
        S: *const arm_merge_sort_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @param[in,out]  S            points to an instance of the sorting structure."]
    #[doc = " @param[in]      dir          Sorting order."]
    #[doc = " @param[in]      buffer       Working buffer."]
    pub fn arm_merge_sort_init_f32(
        S: *mut arm_merge_sort_instance_f32,
        dir: arm_sort_dir::Type,
        buffer: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Copies the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_f64(pSrc: *const float64_t, pDst: *mut float64_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q7 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q7(pSrc: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a floating-point vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_f32(value: float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a floating-point vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_f64(value: float64_t, pDst: *mut float64_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q7 vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q7(value: q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q15 vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q15(value: q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q31 vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q31(value: q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Weighted sum"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]    *in           Array of input values."]
    #[doc = " @param[in]    *weigths      Weights"]
    #[doc = " @param[in]    blockSize     Number of samples in the input array."]
    #[doc = " @return Weighted sum"]
    #[doc = ""]
    pub fn arm_weighted_sum_f32(
        in_: *const float32_t,
        weigths: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief Barycenter"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]    in         List of vectors"]
    #[doc = " @param[in]    weights    Weights of the vectors"]
    #[doc = " @param[out]   out        Barycenter"]
    #[doc = " @param[in]    nbVectors  Number of vectors"]
    #[doc = " @param[in]    vecDim     Dimension of space (vector dimension)"]
    #[doc = " @return       None"]
    #[doc = ""]
    pub fn arm_barycenter_f32(
        in_: *const float32_t,
        weights: *const float32_t,
        out: *mut float32_t,
        nbVectors: u32,
        vecDim: u32,
    );
}
extern "C" {
    #[doc = " @brief        Euclidean distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_euclidean_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Euclidean distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_euclidean_distance_f64(
        pA: *const float64_t,
        pB: *const float64_t,
        blockSize: u32,
    ) -> float64_t;
}
extern "C" {
    #[doc = " @brief        Bray-Curtis distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_braycurtis_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Canberra distance between two vectors"]
    #[doc = ""]
    #[doc = " This function may divide by zero when samples pA[i] and pB[i] are both zero."]
    #[doc = " The result of the computation will be correct. So the division per zero may be"]
    #[doc = " ignored."]
    #[doc = ""]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_canberra_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Chebyshev distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_chebyshev_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Chebyshev distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_chebyshev_distance_f64(
        pA: *const float64_t,
        pB: *const float64_t,
        blockSize: u32,
    ) -> float64_t;
}
extern "C" {
    #[doc = " @brief        Cityblock (Manhattan) distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_cityblock_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Cityblock (Manhattan) distance between two vectors"]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_cityblock_distance_f64(
        pA: *const float64_t,
        pB: *const float64_t,
        blockSize: u32,
    ) -> float64_t;
}
extern "C" {
    #[doc = " @brief        Correlation distance between two vectors"]
    #[doc = ""]
    #[doc = " The input vectors are modified in place !"]
    #[doc = ""]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_correlation_distance_f32(
        pA: *mut float32_t,
        pB: *mut float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Cosine distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_cosine_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Cosine distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_cosine_distance_f64(
        pA: *const float64_t,
        pB: *const float64_t,
        blockSize: u32,
    ) -> float64_t;
}
extern "C" {
    #[doc = " @brief        Jensen-Shannon distance between two vectors"]
    #[doc = ""]
    #[doc = " This function is assuming that elements of second vector are > 0"]
    #[doc = " and 0 only when the corresponding element of first vector is 0."]
    #[doc = " Otherwise the result of the computation does not make sense"]
    #[doc = " and for speed reasons, the cases returning NaN or Infinity are not"]
    #[doc = " managed."]
    #[doc = ""]
    #[doc = " When the function is computing x log (x / y) with x 0 and y 0,"]
    #[doc = " it will compute the right value (0) but a division per zero will occur"]
    #[doc = " and shoudl be ignored in client code."]
    #[doc = ""]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_jensenshannon_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Minkowski distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA         First vector"]
    #[doc = " @param[in]    pB         Second vector"]
    #[doc = " @param[in]    n          Norm order (>= 2)"]
    #[doc = " @param[in]    blockSize  vector length"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_minkowski_distance_f32(
        pA: *const float32_t,
        pB: *const float32_t,
        order: i32,
        blockSize: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Dice distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    order           Distance order"]
    #[doc = " @param[in]    blockSize       Number of samples"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_dice_distance(pA: *const u32, pB: *const u32, numberOfBools: u32) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Hamming distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_hamming_distance(pA: *const u32, pB: *const u32, numberOfBools: u32) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Jaccard distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_jaccard_distance(pA: *const u32, pB: *const u32, numberOfBools: u32) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Kulsinski distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_kulsinski_distance(pA: *const u32, pB: *const u32, numberOfBools: u32) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Roger Stanimoto distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_rogerstanimoto_distance(
        pA: *const u32,
        pB: *const u32,
        numberOfBools: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Russell-Rao distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_russellrao_distance(pA: *const u32, pB: *const u32, numberOfBools: u32)
        -> float32_t;
}
extern "C" {
    #[doc = " @brief        Sokal-Michener distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_sokalmichener_distance(
        pA: *const u32,
        pB: *const u32,
        numberOfBools: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Sokal-Sneath distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_sokalsneath_distance(
        pA: *const u32,
        pB: *const u32,
        numberOfBools: u32,
    ) -> float32_t;
}
extern "C" {
    #[doc = " @brief        Yule distance between two vectors"]
    #[doc = ""]
    #[doc = " @param[in]    pA              First vector of packed booleans"]
    #[doc = " @param[in]    pB              Second vector of packed booleans"]
    #[doc = " @param[in]    numberOfBools   Number of booleans"]
    #[doc = " @return distance"]
    #[doc = ""]
    pub fn arm_yule_distance(pA: *const u32, pB: *const u32, numberOfBools: u32) -> float32_t;
}
#[doc = " @brief Instance structure for linear SVM prediction function."]
#[repr(C)]
pub struct arm_svm_linear_instance_f32 {
    #[doc = "< Number of support vectors"]
    pub nbOfSupportVectors: u32,
    #[doc = "< Dimension of vector space"]
    pub vectorDimension: u32,
    #[doc = "< Intercept"]
    pub intercept: float32_t,
    #[doc = "< Dual coefficients"]
    pub dualCoefficients: *const float32_t,
    #[doc = "< Support vectors"]
    pub supportVectors: *const float32_t,
    #[doc = "< The two SVM classes"]
    pub classes: *const i32,
}
#[test]
fn bindgen_test_layout_arm_svm_linear_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_svm_linear_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_svm_linear_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_svm_linear_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_svm_linear_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_linear_instance_f32>())).nbOfSupportVectors as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_linear_instance_f32),
            "::",
            stringify!(nbOfSupportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_linear_instance_f32>())).vectorDimension as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_linear_instance_f32),
            "::",
            stringify!(vectorDimension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_linear_instance_f32>())).intercept as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_linear_instance_f32),
            "::",
            stringify!(intercept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_linear_instance_f32>())).dualCoefficients as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_linear_instance_f32),
            "::",
            stringify!(dualCoefficients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_linear_instance_f32>())).supportVectors as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_linear_instance_f32),
            "::",
            stringify!(supportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_linear_instance_f32>())).classes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_linear_instance_f32),
            "::",
            stringify!(classes)
        )
    );
}
#[doc = " @brief Instance structure for polynomial SVM prediction function."]
#[repr(C)]
pub struct arm_svm_polynomial_instance_f32 {
    #[doc = "< Number of support vectors"]
    pub nbOfSupportVectors: u32,
    #[doc = "< Dimension of vector space"]
    pub vectorDimension: u32,
    #[doc = "< Intercept"]
    pub intercept: float32_t,
    #[doc = "< Dual coefficients"]
    pub dualCoefficients: *const float32_t,
    #[doc = "< Support vectors"]
    pub supportVectors: *const float32_t,
    #[doc = "< The two SVM classes"]
    pub classes: *const i32,
    #[doc = "< Polynomial degree"]
    pub degree: i32,
    #[doc = "< Polynomial constant"]
    pub coef0: float32_t,
    #[doc = "< Gamma factor"]
    pub gamma: float32_t,
}
#[test]
fn bindgen_test_layout_arm_svm_polynomial_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_svm_polynomial_instance_f32>(),
        56usize,
        concat!("Size of: ", stringify!(arm_svm_polynomial_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_svm_polynomial_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_svm_polynomial_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).nbOfSupportVectors
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(nbOfSupportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).vectorDimension as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(vectorDimension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).intercept as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(intercept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).dualCoefficients
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(dualCoefficients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).supportVectors as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(supportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).classes as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).degree as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(degree)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).coef0 as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(coef0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_polynomial_instance_f32>())).gamma as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_polynomial_instance_f32),
            "::",
            stringify!(gamma)
        )
    );
}
#[doc = " @brief Instance structure for rbf SVM prediction function."]
#[repr(C)]
pub struct arm_svm_rbf_instance_f32 {
    #[doc = "< Number of support vectors"]
    pub nbOfSupportVectors: u32,
    #[doc = "< Dimension of vector space"]
    pub vectorDimension: u32,
    #[doc = "< Intercept"]
    pub intercept: float32_t,
    #[doc = "< Dual coefficients"]
    pub dualCoefficients: *const float32_t,
    #[doc = "< Support vectors"]
    pub supportVectors: *const float32_t,
    #[doc = "< The two SVM classes"]
    pub classes: *const i32,
    #[doc = "< Gamma factor"]
    pub gamma: float32_t,
}
#[test]
fn bindgen_test_layout_arm_svm_rbf_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_svm_rbf_instance_f32>(),
        48usize,
        concat!("Size of: ", stringify!(arm_svm_rbf_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_svm_rbf_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_svm_rbf_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).nbOfSupportVectors as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(nbOfSupportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).vectorDimension as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(vectorDimension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).intercept as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(intercept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).dualCoefficients as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(dualCoefficients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).supportVectors as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(supportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).classes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_svm_rbf_instance_f32>())).gamma as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_rbf_instance_f32),
            "::",
            stringify!(gamma)
        )
    );
}
#[doc = " @brief Instance structure for sigmoid SVM prediction function."]
#[repr(C)]
pub struct arm_svm_sigmoid_instance_f32 {
    #[doc = "< Number of support vectors"]
    pub nbOfSupportVectors: u32,
    #[doc = "< Dimension of vector space"]
    pub vectorDimension: u32,
    #[doc = "< Intercept"]
    pub intercept: float32_t,
    #[doc = "< Dual coefficients"]
    pub dualCoefficients: *const float32_t,
    #[doc = "< Support vectors"]
    pub supportVectors: *const float32_t,
    #[doc = "< The two SVM classes"]
    pub classes: *const i32,
    #[doc = "< Independent constant"]
    pub coef0: float32_t,
    #[doc = "< Gamma factor"]
    pub gamma: float32_t,
}
#[test]
fn bindgen_test_layout_arm_svm_sigmoid_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_svm_sigmoid_instance_f32>(),
        48usize,
        concat!("Size of: ", stringify!(arm_svm_sigmoid_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_svm_sigmoid_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_svm_sigmoid_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).nbOfSupportVectors as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(nbOfSupportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).vectorDimension as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(vectorDimension)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).intercept as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(intercept)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).dualCoefficients as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(dualCoefficients)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).supportVectors as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(supportVectors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).classes as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(classes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).coef0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(coef0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_svm_sigmoid_instance_f32>())).gamma as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_svm_sigmoid_instance_f32),
            "::",
            stringify!(gamma)
        )
    );
}
extern "C" {
    #[doc = " @brief        SVM linear instance init function"]
    #[doc = " @param[in]    S                      Parameters for SVM functions"]
    #[doc = " @param[in]    nbOfSupportVectors     Number of support vectors"]
    #[doc = " @param[in]    vectorDimension        Dimension of vector space"]
    #[doc = " @param[in]    intercept              Intercept"]
    #[doc = " @param[in]    dualCoefficients       Array of dual coefficients"]
    #[doc = " @param[in]    supportVectors         Array of support vectors"]
    #[doc = " @param[in]    classes                Array of 2 classes ID"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_linear_init_f32(
        S: *mut arm_svm_linear_instance_f32,
        nbOfSupportVectors: u32,
        vectorDimension: u32,
        intercept: float32_t,
        dualCoefficients: *const float32_t,
        supportVectors: *const float32_t,
        classes: *const i32,
    );
}
extern "C" {
    #[doc = " @brief SVM linear prediction"]
    #[doc = " @param[in]    S          Pointer to an instance of the linear SVM structure."]
    #[doc = " @param[in]    in         Pointer to input vector"]
    #[doc = " @param[out]   pResult    Decision value"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_linear_predict_f32(
        S: *const arm_svm_linear_instance_f32,
        in_: *const float32_t,
        pResult: *mut i32,
    );
}
extern "C" {
    #[doc = " @brief        SVM polynomial instance init function"]
    #[doc = " @param[in]    S                      points to an instance of the polynomial SVM structure."]
    #[doc = " @param[in]    nbOfSupportVectors     Number of support vectors"]
    #[doc = " @param[in]    vectorDimension        Dimension of vector space"]
    #[doc = " @param[in]    intercept              Intercept"]
    #[doc = " @param[in]    dualCoefficients       Array of dual coefficients"]
    #[doc = " @param[in]    supportVectors         Array of support vectors"]
    #[doc = " @param[in]    classes                Array of 2 classes ID"]
    #[doc = " @param[in]    degree                 Polynomial degree"]
    #[doc = " @param[in]    coef0                  coeff0 (scikit-learn terminology)"]
    #[doc = " @param[in]    gamma                  gamma (scikit-learn terminology)"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_polynomial_init_f32(
        S: *mut arm_svm_polynomial_instance_f32,
        nbOfSupportVectors: u32,
        vectorDimension: u32,
        intercept: float32_t,
        dualCoefficients: *const float32_t,
        supportVectors: *const float32_t,
        classes: *const i32,
        degree: i32,
        coef0: float32_t,
        gamma: float32_t,
    );
}
extern "C" {
    #[doc = " @brief SVM polynomial prediction"]
    #[doc = " @param[in]    S          Pointer to an instance of the polynomial SVM structure."]
    #[doc = " @param[in]    in         Pointer to input vector"]
    #[doc = " @param[out]   pResult    Decision value"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_polynomial_predict_f32(
        S: *const arm_svm_polynomial_instance_f32,
        in_: *const float32_t,
        pResult: *mut i32,
    );
}
extern "C" {
    #[doc = " @brief        SVM radial basis function instance init function"]
    #[doc = " @param[in]    S                      points to an instance of the polynomial SVM structure."]
    #[doc = " @param[in]    nbOfSupportVectors     Number of support vectors"]
    #[doc = " @param[in]    vectorDimension        Dimension of vector space"]
    #[doc = " @param[in]    intercept              Intercept"]
    #[doc = " @param[in]    dualCoefficients       Array of dual coefficients"]
    #[doc = " @param[in]    supportVectors         Array of support vectors"]
    #[doc = " @param[in]    classes                Array of 2 classes ID"]
    #[doc = " @param[in]    gamma                  gamma (scikit-learn terminology)"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_rbf_init_f32(
        S: *mut arm_svm_rbf_instance_f32,
        nbOfSupportVectors: u32,
        vectorDimension: u32,
        intercept: float32_t,
        dualCoefficients: *const float32_t,
        supportVectors: *const float32_t,
        classes: *const i32,
        gamma: float32_t,
    );
}
extern "C" {
    #[doc = " @brief SVM rbf prediction"]
    #[doc = " @param[in]    S         Pointer to an instance of the rbf SVM structure."]
    #[doc = " @param[in]    in        Pointer to input vector"]
    #[doc = " @param[out]   pResult   decision value"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_rbf_predict_f32(
        S: *const arm_svm_rbf_instance_f32,
        in_: *const float32_t,
        pResult: *mut i32,
    );
}
extern "C" {
    #[doc = " @brief        SVM sigmoid instance init function"]
    #[doc = " @param[in]    S                      points to an instance of the rbf SVM structure."]
    #[doc = " @param[in]    nbOfSupportVectors     Number of support vectors"]
    #[doc = " @param[in]    vectorDimension        Dimension of vector space"]
    #[doc = " @param[in]    intercept              Intercept"]
    #[doc = " @param[in]    dualCoefficients       Array of dual coefficients"]
    #[doc = " @param[in]    supportVectors         Array of support vectors"]
    #[doc = " @param[in]    classes                Array of 2 classes ID"]
    #[doc = " @param[in]    coef0                  coeff0 (scikit-learn terminology)"]
    #[doc = " @param[in]    gamma                  gamma (scikit-learn terminology)"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_sigmoid_init_f32(
        S: *mut arm_svm_sigmoid_instance_f32,
        nbOfSupportVectors: u32,
        vectorDimension: u32,
        intercept: float32_t,
        dualCoefficients: *const float32_t,
        supportVectors: *const float32_t,
        classes: *const i32,
        coef0: float32_t,
        gamma: float32_t,
    );
}
extern "C" {
    #[doc = " @brief SVM sigmoid prediction"]
    #[doc = " @param[in]    S        Pointer to an instance of the rbf SVM structure."]
    #[doc = " @param[in]    in       Pointer to input vector"]
    #[doc = " @param[out]   pResult  Decision value"]
    #[doc = " @return none."]
    #[doc = ""]
    pub fn arm_svm_sigmoid_predict_f32(
        S: *const arm_svm_sigmoid_instance_f32,
        in_: *const float32_t,
        pResult: *mut i32,
    );
}
#[doc = " @brief Instance structure for the Q7 FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_q7 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q7_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q7_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q7() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q7>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q7>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q7>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q7>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q7>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_q15 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q15>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q15>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q15>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_q31 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q31>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q31>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q31>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_f32 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f32>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f32>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f32>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_f64 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float64_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float64_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_f64>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_f64))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_f64>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_f64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f64>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f64),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f64>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f64),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f64>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f64),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q7 FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the Q7 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q7(
        S: *const arm_fir_instance_q7,
        pSrc: *const q7_t,
        pDst: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q7 FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q7 FIR structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed."]
    #[doc = ""]
    #[doc = " For the MVE version, the coefficient length must be a multiple of 16."]
    #[doc = " You can pad with zeros if you have less coefficients."]
    pub fn arm_fir_init_q7(
        S: *mut arm_fir_instance_q7,
        numTaps: u16,
        pCoeffs: *const q7_t,
        pState: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q15(
        S: *const arm_fir_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the fast Q15 FIR filter (fast version)."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_fast_q15(
        S: *const arm_fir_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 FIR filter structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greater than or equal to 4."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SUCCESS</code> if initialization was successful or"]
    #[doc = " <code>ARM_MATH_ARGUMENT_ERROR</code> if <code>numTaps</code> is not a supported value."]
    #[doc = ""]
    #[doc = " For the MVE version, the coefficient length must be a multiple of 8."]
    #[doc = " You can pad with zeros if you have less coefficients."]
    #[doc = ""]
    pub fn arm_fir_init_q15(
        S: *mut arm_fir_instance_q15,
        numTaps: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q31(
        S: *const arm_fir_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the fast Q31 FIR filter (fast version)."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_fast_q31(
        S: *const arm_fir_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 FIR structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    #[doc = ""]
    #[doc = " For the MVE version, the coefficient length must be a multiple of 4."]
    #[doc = " You can pad with zeros if you have less coefficients."]
    pub fn arm_fir_init_q31(
        S: *mut arm_fir_instance_q31,
        numTaps: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_f32(
        S: *const arm_fir_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_f64(
        S: *const arm_fir_instance_f64,
        pSrc: *const float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point FIR filter structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    pub fn arm_fir_init_f32(
        S: *mut arm_fir_instance_f32,
        numTaps: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point FIR filter structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    pub fn arm_fir_init_f64(
        S: *mut arm_fir_instance_f64,
        numTaps: u16,
        pCoeffs: *const float64_t,
        pState: *mut float64_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_casd_df1_inst_q15 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: i8,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q15_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const q15_t,
    #[doc = "< Additional shift, in bits, applied to each output sample."]
    pub postShift: i8,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).postShift as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(postShift)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_casd_df1_inst_q31 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u32,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q31_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const q31_t,
    #[doc = "< Additional shift, in bits, applied to each output sample."]
    pub postShift: u8,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).postShift as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(postShift)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_casd_df1_inst_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u32,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_f32>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_q15(
        S: *const arm_biquad_casd_df1_inst_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 Biquad cascade structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cascade_df1_init_q15(
        S: *mut arm_biquad_casd_df1_inst_q15,
        numStages: u8,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        postShift: i8,
    );
}
extern "C" {
    #[doc = " @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q15 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_fast_q15(
        S: *const arm_biquad_casd_df1_inst_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 Biquad cascade filter"]
    #[doc = " @param[in]  S          points to an instance of the Q31 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_q31(
        S: *const arm_biquad_casd_df1_inst_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q31 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_fast_q31(
        S: *const arm_biquad_casd_df1_inst_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 Biquad cascade structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cascade_df1_init_q31(
        S: *mut arm_biquad_casd_df1_inst_q31,
        numStages: u8,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        postShift: i8,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_f32(
        S: *const arm_biquad_casd_df1_inst_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    pub fn arm_biquad_cascade_df1_init_f32(
        S: *mut arm_biquad_casd_df1_inst_f32,
        numStages: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of floating-point sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1."]
    pub fn arm_conv_f32(
        pSrcA: *const float32_t,
        srcALen: u32,
        pSrcB: *const float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen)."]
    pub fn arm_conv_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_fast_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen)."]
    pub fn arm_conv_fast_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q31 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_fast_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q7 sequences."]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    pub fn arm_conv_opt_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q7 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
    );
}
extern "C" {
    #[doc = " @brief Partial convolution of floating-point sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_f32(
        pSrcA: *const float32_t,
        srcALen: u32,
        pSrcB: *const float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen)."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen)."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q31 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q7 sequences"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_opt_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q7 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the Q15 FIR decimator."]
#[repr(C)]
pub struct arm_fir_decimate_instance_q15 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q15_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).M as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).numTaps as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).pCoeffs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).pState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR decimator."]
#[repr(C)]
pub struct arm_fir_decimate_instance_q31 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q31_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).M as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).numTaps as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).pCoeffs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).pState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = "@brief Instance structure for floating-point FIR decimator."]
#[repr(C)]
pub struct arm_fir_decimate_instance_f32 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float32_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).M as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).numTaps as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).pCoeffs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).pState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(pState)
        )
    );
}
extern "C" {
    #[doc = "@brief         Processing function for floating-point FIR decimator."]
    #[doc = "@param[in]     S         points to an instance of the floating-point FIR decimator structure"]
    #[doc = "@param[in]     pSrc      points to the block of input data"]
    #[doc = "@param[out]    pDst      points to the block of output data"]
    #[doc = "@param[in]     blockSize number of samples to process"]
    pub fn arm_fir_decimate_f32(
        S: *const arm_fir_decimate_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = "@brief         Initialization function for the floating-point FIR decimator."]
    #[doc = "@param[in,out] S          points to an instance of the floating-point FIR decimator structure"]
    #[doc = "@param[in]     numTaps    number of coefficients in the filter"]
    #[doc = "@param[in]     M          decimation factor"]
    #[doc = "@param[in]     pCoeffs    points to the filter coefficients"]
    #[doc = "@param[in]     pState     points to the state buffer"]
    #[doc = "@param[in]     blockSize  number of input samples to process per call"]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS      : Operation successful"]
    #[doc = "- \\ref ARM_MATH_LENGTH_ERROR : <code>blockSize</code> is not a multiple of <code>M</code>"]
    pub fn arm_fir_decimate_init_f32(
        S: *mut arm_fir_decimate_instance_f32,
        numTaps: u16,
        M: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR decimator."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR decimator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_q15(
        S: *const arm_fir_decimate_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR decimator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_fast_q15(
        S: *const arm_fir_decimate_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR decimator."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 FIR decimator structure."]
    #[doc = " @param[in]     numTaps    number of coefficients in the filter."]
    #[doc = " @param[in]     M          decimation factor."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_q15(
        S: *mut arm_fir_decimate_instance_q15,
        numTaps: u16,
        M: u8,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR decimator."]
    #[doc = " @param[in]  S     points to an instance of the Q31 FIR decimator structure."]
    #[doc = " @param[in]  pSrc  points to the block of input data."]
    #[doc = " @param[out] pDst  points to the block of output data"]
    #[doc = " @param[in] blockSize number of input samples to process per call."]
    pub fn arm_fir_decimate_q31(
        S: *const arm_fir_decimate_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR decimator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_fast_q31(
        S: *const arm_fir_decimate_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR decimator."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 FIR decimator structure."]
    #[doc = " @param[in]     numTaps    number of coefficients in the filter."]
    #[doc = " @param[in]     M          decimation factor."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_q31(
        S: *mut arm_fir_decimate_instance_q31,
        numTaps: u16,
        M: u8,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the Q15 FIR interpolator."]
#[repr(C)]
pub struct arm_fir_interpolate_instance_q15 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *const q15_t,
    #[doc = "< points to the state variable array. The array is of length blockSize+phaseLength-1."]
    pub pState: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_q15>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_q15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).L as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).phaseLength as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).pCoeffs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).pState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR interpolator."]
#[repr(C)]
pub struct arm_fir_interpolate_instance_q31 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *const q31_t,
    #[doc = "< points to the state variable array. The array is of length blockSize+phaseLength-1."]
    pub pState: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_q31>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_q31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).L as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).phaseLength as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).pCoeffs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).pState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR interpolator."]
#[repr(C)]
pub struct arm_fir_interpolate_instance_f32 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *const float32_t,
    #[doc = "< points to the state variable array. The array is of length phaseLength+numTaps-1."]
    pub pState: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).L as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).phaseLength as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).pCoeffs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).pState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(pState)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR interpolator."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR interpolator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_q15(
        S: *const arm_fir_interpolate_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR interpolator."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 FIR interpolator structure."]
    #[doc = " @param[in]     L          upsample factor."]
    #[doc = " @param[in]     numTaps    number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficient buffer."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_q15(
        S: *mut arm_fir_interpolate_instance_q15,
        L: u8,
        numTaps: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR interpolator."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR interpolator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_q31(
        S: *const arm_fir_interpolate_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR interpolator."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 FIR interpolator structure."]
    #[doc = " @param[in]     L          upsample factor."]
    #[doc = " @param[in]     numTaps    number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficient buffer."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_q31(
        S: *mut arm_fir_interpolate_instance_q31,
        L: u8,
        numTaps: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR interpolator."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR interpolator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_f32(
        S: *const arm_fir_interpolate_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR interpolator."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point FIR interpolator structure."]
    #[doc = " @param[in]     L          upsample factor."]
    #[doc = " @param[in]     numTaps    number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficient buffer."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_f32(
        S: *mut arm_fir_interpolate_instance_f32,
        L: u8,
        numTaps: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the high precision Q31 Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cas_df1_32x64_ins_q31 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q63_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const q31_t,
    #[doc = "< additional shift, in bits, applied to each output sample."]
    pub postShift: u8,
}
#[test]
fn bindgen_test_layout_arm_biquad_cas_df1_32x64_ins_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cas_df1_32x64_ins_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_biquad_cas_df1_32x64_ins_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cas_df1_32x64_ins_q31>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).numStages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).pState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).pCoeffs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).postShift as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cas_df1_32x64_q31(
        S: *const arm_biquad_cas_df1_32x64_ins_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filter structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     postShift  shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cas_df1_32x64_init_q31(
        S: *mut arm_biquad_cas_df1_32x64_ins_q31,
        numStages: u8,
        pCoeffs: *const q31_t,
        pState: *mut q63_t,
        postShift: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cascade_df2T_instance_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 2*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_df2T_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_df2T_instance_f32>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_df2T_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_df2T_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f32>())).numStages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f32>())).pState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f32>())).pCoeffs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cascade_stereo_df2T_instance_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_stereo_df2T_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_stereo_df2T_instance_f32>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_stereo_df2T_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_stereo_df2T_instance_f32>())).numStages
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_stereo_df2T_instance_f32>())).pState
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_stereo_df2T_instance_f32>())).pCoeffs
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cascade_df2T_instance_f64 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 2*numStages."]
    pub pState: *mut float64_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float64_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_df2T_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_df2T_instance_f64>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_df2T_instance_f64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_df2T_instance_f64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f64>())).numStages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f64>())).pState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f64>())).pCoeffs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the filter data structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df2T_f32(
        S: *const arm_biquad_cascade_df2T_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels"]
    #[doc = " @param[in]  S          points to an instance of the filter data structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_stereo_df2T_f32(
        S: *const arm_biquad_cascade_stereo_df2T_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the filter data structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df2T_f64(
        S: *const arm_biquad_cascade_df2T_instance_f64,
        pSrc: *const float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the filter data structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df2T_init_f32(
        S: *mut arm_biquad_cascade_df2T_instance_f32,
        numStages: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the filter data structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_stereo_df2T_init_f32(
        S: *mut arm_biquad_cascade_stereo_df2T_instance_f32,
        numStages: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the filter data structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df2T_init_f64(
        S: *mut arm_biquad_cascade_df2T_instance_f64,
        numStages: u8,
        pCoeffs: *const float64_t,
        pState: *mut float64_t,
    );
}
#[doc = " @brief Instance structure for the Q15 FIR lattice filter."]
#[repr(C)]
pub struct arm_fir_lattice_instance_q15 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *const q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q15>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR lattice filter."]
#[repr(C)]
pub struct arm_fir_lattice_instance_q31 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *const q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q31>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR lattice filter."]
#[repr(C)]
pub struct arm_fir_lattice_instance_f32 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_f32>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 FIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the Q15 FIR lattice structure."]
    #[doc = " @param[in] numStages  number of filter stages."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages."]
    pub fn arm_fir_lattice_init_q15(
        S: *mut arm_fir_lattice_instance_q15,
        numStages: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_q15(
        S: *const arm_fir_lattice_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q31 FIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 FIR lattice structure."]
    #[doc = " @param[in] numStages  number of filter stages."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pState     points to the state buffer.   The array is of length numStages."]
    pub fn arm_fir_lattice_init_q31(
        S: *mut arm_fir_lattice_instance_q31,
        numStages: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_q31(
        S: *const arm_fir_lattice_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point FIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point FIR lattice structure."]
    #[doc = " @param[in] numStages  number of filter stages."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages."]
    pub fn arm_fir_lattice_init_f32(
        S: *mut arm_fir_lattice_instance_f32,
        numStages: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_f32(
        S: *const arm_fir_lattice_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 IIR lattice filter."]
#[repr(C)]
pub struct arm_iir_lattice_instance_q15 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut q15_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut q15_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).pkCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).pvCoeffs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 IIR lattice filter."]
#[repr(C)]
pub struct arm_iir_lattice_instance_q31 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut q31_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut q31_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).pkCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).pvCoeffs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point IIR lattice filter."]
#[repr(C)]
pub struct arm_iir_lattice_instance_f32 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut float32_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut float32_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).pkCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).pvCoeffs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point IIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point IIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_f32(
        S: *const arm_iir_lattice_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point IIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point IIR lattice structure."]
    #[doc = " @param[in] numStages  number of stages in the filter."]
    #[doc = " @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-1."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_iir_lattice_init_f32(
        S: *mut arm_iir_lattice_instance_f32,
        numStages: u16,
        pkCoeffs: *mut float32_t,
        pvCoeffs: *mut float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 IIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 IIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_q31(
        S: *const arm_iir_lattice_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q31 IIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 IIR lattice structure."]
    #[doc = " @param[in] numStages  number of stages in the filter."]
    #[doc = " @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_iir_lattice_init_q31(
        S: *mut arm_iir_lattice_instance_q31,
        numStages: u16,
        pkCoeffs: *mut q31_t,
        pvCoeffs: *mut q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 IIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 IIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_q15(
        S: *const arm_iir_lattice_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 IIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure."]
    #[doc = " @param[in] numStages  number of stages in the filter."]
    #[doc = " @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1."]
    #[doc = " @param[in] pState     points to state buffer.  The array is of length numStages+blockSize."]
    #[doc = " @param[in] blockSize  number of samples to process per call."]
    pub fn arm_iir_lattice_init_q15(
        S: *mut arm_iir_lattice_instance_q15,
        numStages: u16,
        pkCoeffs: *mut q15_t,
        pvCoeffs: *mut q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the floating-point LMS filter."]
#[repr(C)]
pub struct arm_lms_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: float32_t,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(mu)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for floating-point LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_f32(
        S: *const arm_lms_instance_f32,
        pSrc: *const float32_t,
        pRef: *mut float32_t,
        pOut: *mut float32_t,
        pErr: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for floating-point LMS filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_lms_init_f32(
        S: *mut arm_lms_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        mu: float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 LMS filter."]
#[repr(C)]
pub struct arm_lms_instance_q15 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q15_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u32,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).postShift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q15 LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer."]
    #[doc = " @param[in] pState     points to the state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_init_q15(
        S: *mut arm_lms_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        mu: q15_t,
        blockSize: u32,
        postShift: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q15 LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_q15(
        S: *const arm_lms_instance_q15,
        pSrc: *const q15_t,
        pRef: *mut q15_t,
        pOut: *mut q15_t,
        pErr: *mut q15_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q31 LMS filter."]
#[repr(C)]
pub struct arm_lms_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q31_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u32,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).postShift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q31 LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_q31(
        S: *const arm_lms_instance_q31,
        pSrc: *const q31_t,
        pRef: *mut q31_t,
        pOut: *mut q31_t,
        pErr: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q31 LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_init_q31(
        S: *mut arm_lms_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        mu: q31_t,
        blockSize: u32,
        postShift: u32,
    );
}
#[doc = " @brief Instance structure for the floating-point normalized LMS filter."]
#[repr(C)]
pub struct arm_lms_norm_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< step size that control filter coefficient updates."]
    pub mu: float32_t,
    #[doc = "< saves previous frame energy."]
    pub energy: float32_t,
    #[doc = "< saves previous input sample."]
    pub x0: float32_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).energy as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).x0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for floating-point normalized LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point normalized LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_f32(
        S: *mut arm_lms_norm_instance_f32,
        pSrc: *const float32_t,
        pRef: *mut float32_t,
        pOut: *mut float32_t,
        pErr: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for floating-point normalized LMS filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_lms_norm_init_f32(
        S: *mut arm_lms_norm_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        mu: float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q31 normalized LMS filter."]
#[repr(C)]
pub struct arm_lms_norm_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q31_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u8,
    #[doc = "< points to the reciprocal initial value table."]
    pub recipTable: *const q31_t,
    #[doc = "< saves previous frame energy."]
    pub energy: q31_t,
    #[doc = "< saves previous input sample."]
    pub x0: q31_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_q31>(),
        48usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).postShift as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(postShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).recipTable as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(recipTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).energy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).x0 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q31 normalized LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 normalized LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_q31(
        S: *mut arm_lms_norm_instance_q31,
        pSrc: *const q31_t,
        pRef: *mut q31_t,
        pOut: *mut q31_t,
        pErr: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q31 normalized LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 normalized LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_norm_init_q31(
        S: *mut arm_lms_norm_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        mu: q31_t,
        blockSize: u32,
        postShift: u8,
    );
}
#[doc = " @brief Instance structure for the Q15 normalized LMS filter."]
#[repr(C)]
pub struct arm_lms_norm_instance_q15 {
    #[doc = "< Number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q15_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u8,
    #[doc = "< Points to the reciprocal initial value table."]
    pub recipTable: *const q15_t,
    #[doc = "< saves previous frame energy."]
    pub energy: q15_t,
    #[doc = "< saves previous input sample."]
    pub x0: q15_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_q15>(),
        48usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).postShift as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(postShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).recipTable as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(recipTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).energy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).x0 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q15 normalized LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 normalized LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_q15(
        S: *mut arm_lms_norm_instance_q15,
        pSrc: *const q15_t,
        pRef: *mut q15_t,
        pOut: *mut q15_t,
        pErr: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q15 normalized LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q15 normalized LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_norm_init_q15(
        S: *mut arm_lms_norm_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        mu: q15_t,
        blockSize: u32,
        postShift: u8,
    );
}
extern "C" {
    #[doc = " @brief Correlation of floating-point sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_f32(
        pSrcA: *const float32_t,
        srcALen: u32,
        pSrcB: *const float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of floating-point sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_f64(
        pSrcA: *const float64_t,
        srcALen: u32,
        pSrcB: *const float64_t,
        srcBLen: u32,
        pDst: *mut float64_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q15 sequences"]
    #[doc = "@param[in]  pSrcA     points to the first input sequence"]
    #[doc = "@param[in]  srcALen   length of the first input sequence"]
    #[doc = "@param[in]  pSrcB     points to the second input sequence"]
    #[doc = "@param[in]  srcBLen   length of the second input sequence"]
    #[doc = "@param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = "@param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    pub fn arm_correlate_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q15 sequences."]
    #[doc = "@param[in]  pSrcA    points to the first input sequence"]
    #[doc = "@param[in]  srcALen  length of the first input sequence"]
    #[doc = "@param[in]  pSrcB    points to the second input sequence"]
    #[doc = "@param[in]  srcBLen  length of the second input sequence"]
    #[doc = "@param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief         Correlation of Q15 sequences (fast version)."]
    #[doc = "@param[in]     pSrcA      points to the first input sequence"]
    #[doc = "@param[in]     srcALen    length of the first input sequence"]
    #[doc = "@param[in]     pSrcB      points to the second input sequence"]
    #[doc = "@param[in]     srcBLen    length of the second input sequence"]
    #[doc = "@param[out]    pDst       points to the location where the output result is written.  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = "@return        none"]
    pub fn arm_correlate_fast_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q15 sequences (fast version)."]
    #[doc = "@param[in]  pSrcA     points to the first input sequence."]
    #[doc = "@param[in]  srcALen   length of the first input sequence."]
    #[doc = "@param[in]  pSrcB     points to the second input sequence."]
    #[doc = "@param[in]  srcBLen   length of the second input sequence."]
    #[doc = "@param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = "@param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    pub fn arm_correlate_fast_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q31 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q31 sequences (fast version)."]
    #[doc = "@param[in]  pSrcA    points to the first input sequence"]
    #[doc = "@param[in]  srcALen  length of the first input sequence"]
    #[doc = "@param[in]  pSrcB    points to the second input sequence"]
    #[doc = "@param[in]  srcBLen  length of the second input sequence"]
    #[doc = "@param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_fast_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q7 sequences."]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    pub fn arm_correlate_opt_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q7 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
    );
}
#[doc = " @brief Instance structure for the floating-point sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float32_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q31_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q31>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_q15 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q15_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q15>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q7 sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_q7 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q7_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q7_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q7() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q7>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q7>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q7))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pTapDelay)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point sparse FIR filter."]
    #[doc = " @param[in]  S           points to an instance of the floating-point sparse FIR structure."]
    #[doc = " @param[in]  pSrc        points to the block of input data."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  pScratchIn  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize   number of input samples to process per call."]
    pub fn arm_fir_sparse_f32(
        S: *mut arm_fir_sparse_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        pScratchIn: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_f32(
        S: *mut arm_fir_sparse_instance_f32,
        numTaps: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 sparse FIR filter."]
    #[doc = " @param[in]  S           points to an instance of the Q31 sparse FIR structure."]
    #[doc = " @param[in]  pSrc        points to the block of input data."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  pScratchIn  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize   number of input samples to process per call."]
    pub fn arm_fir_sparse_q31(
        S: *mut arm_fir_sparse_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        pScratchIn: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q31(
        S: *mut arm_fir_sparse_instance_q31,
        numTaps: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 sparse FIR filter."]
    #[doc = " @param[in]  S            points to an instance of the Q15 sparse FIR structure."]
    #[doc = " @param[in]  pSrc         points to the block of input data."]
    #[doc = " @param[out] pDst         points to the block of output data"]
    #[doc = " @param[in]  pScratchIn   points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  pScratchOut  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize    number of input samples to process per call."]
    pub fn arm_fir_sparse_q15(
        S: *mut arm_fir_sparse_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        pScratchIn: *mut q15_t,
        pScratchOut: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q15(
        S: *mut arm_fir_sparse_instance_q15,
        numTaps: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q7 sparse FIR filter."]
    #[doc = " @param[in]  S            points to an instance of the Q7 sparse FIR structure."]
    #[doc = " @param[in]  pSrc         points to the block of input data."]
    #[doc = " @param[out] pDst         points to the block of output data"]
    #[doc = " @param[in]  pScratchIn   points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  pScratchOut  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize    number of input samples to process per call."]
    pub fn arm_fir_sparse_q7(
        S: *mut arm_fir_sparse_instance_q7,
        pSrc: *const q7_t,
        pDst: *mut q7_t,
        pScratchIn: *mut q7_t,
        pScratchOut: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q7 sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q7 sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q7(
        S: *mut arm_fir_sparse_instance_q7,
        numTaps: u16,
        pCoeffs: *const q7_t,
        pState: *mut q7_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = "@brief         Levinson Durbin"]
    #[doc = "@param[in]     phi      autocovariance vector starting with lag 0 (length is nbCoefs + 1)"]
    #[doc = "@param[out]    a        autoregressive coefficients"]
    #[doc = "@param[out]    err      prediction error (variance)"]
    #[doc = "@param[in]     nbCoefs  number of autoregressive coefficients"]
    #[doc = "@return        none"]
    pub fn arm_levinson_durbin_f32(
        phi: *const float32_t,
        a: *mut float32_t,
        err: *mut float32_t,
        nbCoefs: crate::ctypes::c_int,
    );
}
extern "C" {
    #[doc = "@brief         Levinson Durbin"]
    #[doc = "@param[in]     phi      autocovariance vector starting with lag 0 (length is nbCoefs + 1)"]
    #[doc = "@param[out]    a        autoregressive coefficients"]
    #[doc = "@param[out]    err      prediction error (variance)"]
    #[doc = "@param[in]     nbCoefs  number of autoregressive coefficients"]
    #[doc = "@return        none"]
    pub fn arm_levinson_durbin_q31(
        phi: *const q31_t,
        a: *mut q31_t,
        err: *mut q31_t,
        nbCoefs: crate::ctypes::c_int,
    );
}
extern "C" {
    #[doc = "@brief         Floating-point quaternion Norm."]
    #[doc = "@param[in]     pInputQuaternions       points to the input vector of quaternions"]
    #[doc = "@param[out]    pNorms                  points to the output vector of norms"]
    #[doc = "@param[in]     nbQuaternions           number of quaternions in each vector"]
    #[doc = "@return        none"]
    pub fn arm_quaternion_norm_f32(
        pInputQuaternions: *const float32_t,
        pNorms: *mut float32_t,
        nbQuaternions: u32,
    );
}
extern "C" {
    #[doc = "@brief         Floating-point quaternion inverse."]
    #[doc = "@param[in]     pInputQuaternions            points to the input vector of quaternions"]
    #[doc = "@param[out]    pInverseQuaternions          points to the output vector of inverse quaternions"]
    #[doc = "@param[in]     nbQuaternions                number of quaternions in each vector"]
    #[doc = "@return        none"]
    pub fn arm_quaternion_inverse_f32(
        pInputQuaternions: *const float32_t,
        pInverseQuaternions: *mut float32_t,
        nbQuaternions: u32,
    );
}
extern "C" {
    #[doc = "@brief         Floating-point quaternion conjugates."]
    #[doc = "@param[in]     pInputQuaternions            points to the input vector of quaternions"]
    #[doc = "@param[out]    pConjugateQuaternions        points to the output vector of conjugate quaternions"]
    #[doc = "@param[in]     nbQuaternions                number of quaternions in each vector"]
    #[doc = "@return        none"]
    pub fn arm_quaternion_conjugate_f32(
        inputQuaternions: *const float32_t,
        pConjugateQuaternions: *mut float32_t,
        nbQuaternions: u32,
    );
}
extern "C" {
    #[doc = "@brief         Floating-point normalization of quaternions."]
    #[doc = "@param[in]     pInputQuaternions            points to the input vector of quaternions"]
    #[doc = "@param[out]    pNormalizedQuaternions       points to the output vector of normalized quaternions"]
    #[doc = "@param[in]     nbQuaternions                number of quaternions in each vector"]
    #[doc = "@return        none"]
    pub fn arm_quaternion_normalize_f32(
        inputQuaternions: *const float32_t,
        pNormalizedQuaternions: *mut float32_t,
        nbQuaternions: u32,
    );
}
extern "C" {
    #[doc = "@brief         Floating-point product of two quaternions."]
    #[doc = "@param[in]     qa       First quaternion"]
    #[doc = "@param[in]     qb       Second quaternion"]
    #[doc = "@param[out]    r        Product of two quaternions"]
    #[doc = "@return        none"]
    pub fn arm_quaternion_product_single_f32(
        qa: *const float32_t,
        qb: *const float32_t,
        r: *mut float32_t,
    );
}
extern "C" {
    #[doc = "@brief         Floating-point elementwise product two quaternions."]
    #[doc = "@param[in]     qa                  First array of quaternions"]
    #[doc = "@param[in]     qb                  Second array of quaternions"]
    #[doc = "@param[out]    r                   Elementwise product of quaternions"]
    #[doc = "@param[in]     nbQuaternions       Number of quaternions in the array"]
    #[doc = "@return        none"]
    pub fn arm_quaternion_product_f32(
        qa: *const float32_t,
        qb: *const float32_t,
        r: *mut float32_t,
        nbQuaternions: u32,
    );
}
extern "C" {
    #[doc = " @brief Conversion of quaternion to equivalent rotation matrix."]
    #[doc = " @param[in]       pInputQuaternions points to an array of normalized quaternions"]
    #[doc = " @param[out]      pOutputRotations points to an array of 3x3 rotations (in row order)"]
    #[doc = " @param[in]       nbQuaternions in the array"]
    #[doc = " @return none."]
    #[doc = ""]
    #[doc = " <b>Format of rotation matrix</b>"]
    #[doc = " \\par"]
    #[doc = " The quaternion a + ib + jc + kd is converted into rotation matrix:"]
    #[doc = "   a^2 + b^2 - c^2 - d^2                 2bc - 2ad                 2bd + 2ac"]
    #[doc = "               2bc + 2ad     a^2 - b^2 + c^2 - d^2                 2cd - 2ab"]
    #[doc = "               2bd - 2ac                 2cd + 2ab     a^2 - b^2 - c^2 + d^2"]
    #[doc = ""]
    #[doc = " Rotation matrix is saved in row order : R00 R01 R02 R10 R11 R12 R20 R21 R22"]
    pub fn arm_quaternion2rotation_f32(
        pInputQuaternions: *const float32_t,
        pOutputRotations: *mut float32_t,
        nbQuaternions: u32,
    );
}
extern "C" {
    #[doc = " @brief Conversion of a rotation matrix to equivalent quaternion."]
    #[doc = " @param[in]       pInputRotations points to an array 3x3 rotation matrix (in row order)"]
    #[doc = " @param[out]      pOutputQuaternions points to an array of quaternions"]
    #[doc = " @param[in]       nbQuaternions in the array"]
    #[doc = " @return none."]
    pub fn arm_rotation2quaternion_f32(
        pInputRotations: *const float32_t,
        pOutputQuaternions: *mut float32_t,
        nbQuaternions: u32,
    );
}
